{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/AnalyzingBinaries",
    "result": {"pageContext":{"currentCategory":"AnalyzingBinaries","categories":["All","Blockchain","Solana","0-day","CLOUD","Web","projects","Talk","troubleshooting","Windows","AnalyzingBinaries","ARM","windows","1-day","CTF","Mobile","Tools","Theory","Language"],"edges":[{"node":{"id":"f23f11a7-6019-532c-aa13-5778ab1d1599","excerpt":"Linekd List Node, Element 리스트의 데이터 각각의 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 있다. 처음, 끝 부분은 각자만의 ,  갖는다. 한 노드 바로 앞에 있는 노드는  한 노드 바로 뒤에 있는 노드는  연결리스트 구성 데이터를 연결 리스트에 삽입할 때 노드용 객체를 만든다. 삭제할 때 노드용 객체를 없애면 데이터 추가 삭제를 효율적으로 할 수 있다.  Self-referential 형(자기 자신과 같은 자료형의 객체를 가리크는 데이터를 가지고 있는 자료구조) Tail Node는 next node를 갖지 않기 때문에 next 값은 (NULL) 값을 대입한다. 소스 코드 nodeAlloc 함수 Node 형 객체를 만들고 만든 객체의 포인터를 반환한다. setNode 함수 노드의 멤버 값을 설정 Node형 객체의 두 멈베(data, next)의 값을 설정하는 함수 첫 번째 매개 변수 n으로 전달받은 포인터가 가리키는 Node 형 객체에 x가 가리키는…","fields":{"slug":"/linked_list_/"},"frontmatter":{"categories":"AnalyzingBinaries","title":"연결 리스트 구조 공격 벡터 선정 (Intel arch)","date":"March 01, 2021"}},"next":{"fields":{"slug":"/arm-8/"}},"previous":{"fields":{"slug":"/window_allocator_/"}}},{"node":{"id":"98b5d6a1-bf12-5992-b9fe-c28ff9d28a92","excerpt":"Objdump GNU Binutils 난독화 되지 않은 일반적인 바이너리를 디스어셈블링하여 작업할 수 있다. 일반적인 ELF 형식이라면 모두 읽을 수 있다. 예제 바이너리 ELF 파일의 모든 섹션, 데이터/코드 출력  ELF 파일의 프로그램 코드 출력  ELF 파일 모든 심볼 출력  Strace System Call Trace ptrace(2) 시스템 콜을 기반으로 하는 도구 프로그램이 실행되는 동안  활동에 대한 정보와 수집되는 시그널을 보여주기 위해 루프 안에서  요청을 사용한다. 프로세스를 디버깅하거나 실행 중일 때 어떤 syscall이 호출되는지에 대해 정보 수집으로 유용하다.  ltrace 라이브러리 트레이스 strace와 유사하다. 프로그램의 공유 라이브러리 링킹 정보를 파싱하고 사용되는 라이브러리 함수를 출력한다. 시스템 콜 외에 라이브러리 함수 호출도 확인하고자 할시  플래그를 사용한다. 실행 파일의 동적 세그먼트를 파싱하고 실제 공유 라이브러리와 정적 라이브러리의 …","fields":{"slug":"/elf_device_file5/"},"frontmatter":{"categories":"AnalyzingBinaries","title":"ELF 분석 도구","date":"August 16, 2020"}},"next":{"fields":{"slug":"/elf_device_file4/"}},"previous":{"fields":{"slug":"/zer0pts_music_ctf_writeup/"}}},{"node":{"id":"e309f9e0-4586-5d4e-ba46-69ed10a20d3f","excerpt":"ELF 프로그램 헤더 ELF 프로그램 헤더는 프로그램 로딩에 필요한 를 정의한다. 는 디스크에 저장된 실행 파일이 커널에 의해 로드되는 과정에서 어떤 메모리 구조로 매핑될 것인지를 정의한다. 프로그램 헤더 테이블은 ELF 헤더의 멤버인  (프로그램 헤더 테이블 오프셋)를 조회해 접근한다. 주로 사용하는 프로그램 헤더는 5가지로 실행 파일 및 공유 라이브러리의 세그먼트를 정의하고 세그먼트 형식(어떤 형식의 데이터 또는 코드가 있는지를 나타낸다.) 32비트 ELF 실행 파일의 프로그램 헤더 테이블을 조회해  구조체가 형성하는 프로그램 헤더를 분석해도록 하겠다. PT_LOAD 실행 파일에는  형식의 세그먼트가 하나 이상 있어야 한다. 해당 형식의 프로그램 헤더는 로드 가능한 세그먼트 형식으로 메모리에 로드 또는 매핑된다. 두 세그먼트는  값을 이용해 정렬된 후 메모리에 매핑된다. Phdr 구조체가 나타내는 세그먼트가 파일과 메모리에서 어떤 방식으로 동작하는지 이해하기 위해 리눅스의  페…","fields":{"slug":"/elf_device_file4/"},"frontmatter":{"categories":"AnalyzingBinaries","title":"ELF 프로그램 헤더 (ELF Program Header)","date":"August 16, 2020"}},"next":{"fields":{"slug":"/hitcon2017_sakura_ctf_writeup/2020-08-16-HITCON2017-sakura/"}},"previous":{"fields":{"slug":"/elf_device_file5/"}}},{"node":{"id":"be8c73c9-a412-5fbd-8828-bacf94912612","excerpt":"ELF 파일 형식 ET_NONE(ELF type none)  파일은 아직 정의되지 않았거나 알 수 없다. ET_REL(ELF Type relocatable) 재배열이 가능한 파일 형식 이 형식의 파일은 파일의 전체 또는 일부가 재배열 가능하다. 재배열 가능한 파일은 위치 독립 코드 (PIC, Position Independent Code) 라고 한다.  코드를 컴파일 해 얻을 수 있는  파일은 실행 파일을 생성하는 데 필요한 코드와 데이터를 포함한다. ET_EXEC(ELF executable) 실행 파일 형식이다. 이 형식의 파일은 실행 파일이며 프로그램이라고 부른다. 프로세스의 시작 지점인 Entry Point가 있다. ET_DYN(ELF type dynamic) 공유 오브젝트 파일 형식 동적 링킹이 가능한 오브젝트 파일로 공유 라이브러리하고도 함 실행 시간(runtime) 에 프로그램의 프로세스 이미지로 로드되고 링크된다. ET_CORE(ELF type core) 코어 파일 형…","fields":{"slug":"/elf_device_file2/2020-08-16-ELF-file-format/"},"frontmatter":{"categories":"AnalyzingBinaries","title":"ELF 파일 형식 (ELF file format)","date":"August 16, 2020"}},"next":{"fields":{"slug":"/elf_device_file3/"}},"previous":{"fields":{"slug":"/hitcon2017_sakura_ctf_writeup/2020-08-16-HITCON2017-sakura/"}}},{"node":{"id":"ad1d6292-b2dd-5378-a8c7-d97b14e48b7c","excerpt":"LD_PRELOAD 환경 변수 다른 라이브러리보다 먼저 동적으로 링크하도록 라이브러리 경로를 지정한다. 해당 설정은 사전에 로드하는 라이브러리의 함수나 심볼을 나중에 링크되는 라이브러리 함수나 심볼을 오버라이드 한다. 공유 라이브러리 함수를 리다렉션하여 런타임 패치를 수행한다. LD_SHOW_AUXV 환경 변수 실행하는 동안 프로그램의 보조 벡터를 출력하도록 프로그램 로더에게 알린다.  는 프로그램의 스택 (커널의 ELF 로딩 루틴에 의한)에 위치한 정보로 프로그램에 관한 특정 정보와 함께 동적 링커로 전달된다. 해당 정보는 리버싱과 디버깅에 유용하다.  프로세스 이미지에 위치한  페이지의 메모리 주소는  를 확인해야 한다. 링커 스크립트 링커 스크립트는 링커가 해석해 섹션, 메모리, 심볼 등 프로그램의 레이아웃을 구성한다. 기본 링커 스크립터는  명령어로 확인한다.  링커 프로그램은 (재배치 가능한 객체 파일, 공유 라이브러리, 헤더 파일 등) 입력 파일을 받을 때 해석된다. 해…","fields":{"slug":"/elf_device_file3/"},"frontmatter":{"categories":"AnalyzingBinaries","title":"리눅스 링커 환경 변수","date":"August 16, 2020"}},"next":{"fields":{"slug":"/elf_device_file1/"}},"previous":{"fields":{"slug":"/elf_device_file2/2020-08-16-ELF-file-format/"}}},{"node":{"id":"b6a5109c-3ab5-58e6-9a66-7219894bc636","excerpt":"Device File /proc//maps 각 메모리 매핑을 표시해 프로세스 이미지에 대한 레이아웃을 가진다. 실행 파일, 공유 라이브러리, 스택, 힙, VDSO 등이 포함된다. 프로세스 주소 공간의 배치를 신속히 분석할 때 매우 중요하다.  /proc/kcore proc 파일시스템에 있는 엔트리로 리눅스 커널의 동적 코어 파일처럼 행동한다. GDB에 커널 디버깅과 분석을 목적으로 사용할 수있는 ELF 코어 파일 형태인 로우 메모리 덤프이다. /boot/System.map 모든 리눅스 배포판에서 사용할 수 있고 커널 해커에게 아주 유용하다. 전체 커널의 모든 심볼이 담겨 있다. /proc/kallsyms kallsyms는 /proc 엔트리만 제외하고 커널이 관리하고 동적으로 업데이트하여  과 매우 유사하다. 새로운 LKM을 설치하면 심볼은 /proc/kallsyms에 바로 추가된다. /proc/kallsyms는 대부분의 심볼과  커널 설정에 명시된 것 전부가 포함된다.  /proc…","fields":{"slug":"/elf_device_file1/"},"frontmatter":{"categories":"AnalyzingBinaries","title":"ELF 분석에 유용한 디바이스 파일 (Device File)","date":"August 16, 2020"}},"next":{"fields":{"slug":"/docker_python_tbs/"}},"previous":{"fields":{"slug":"/elf_device_file3/"}}},{"node":{"id":"a5f2d145-a5eb-5a18-83b7-adda8a8dabfa","excerpt":"angr fauxware 문제 풀이 문제 바이너리 dnsdudrla97/angr-doc data 섹션  authenticate 함수   전역 변수가 가리키고 있는 문자열 과 유저 이름을  함수를 바탕으로 비교를 통해 같으면 1을 반환하고 아닐시 유저 이름에 해당 하는 파일 이름을  함수를 바탕으로 읽고 해당 값과 유저 패스워드와 비교하여 같으면 1을 반환 아니면 0을 반환한다. 우리가 피해야할 주소 값은  임을 알 수있다.  접근해야 하는 위치  기본적으로 앞에서  함수에서 반환된 값이 1 일 경우  함수를 호출하게 된다.  angr solve 1  angr sovle 2  data 섹션 authenticate 함수 접근해야 하는 위치 angr solve 1 angr sovle 2","fields":{"slug":"/angr-3_theori/"},"frontmatter":{"categories":"AnalyzingBinaries","title":"angr 바이너리 분석 활용 방안 3","date":"August 14, 2020"}},"next":{"fields":{"slug":"/angr-2_theori/"}},"previous":{"fields":{"slug":"/codegate2018_redvelbet_ctf_writeup/"}}},{"node":{"id":"f6538b07-37c9-5934-8a8a-c3719dbe59ea","excerpt":"The Loader  를 로드하고 로더와 상호 작용 하는 방법에 대해 알아보자 예제로 사용할 바이너리는 다음 링크에서 다운로드: dnsdudrla97/angr-doc Loaded Objects CLE 로더 (cle.Loader)는 로드된 바이너리 객체의 전체 그룹을 나타내며 단일 메모리 공간에 로드되고 매핑된다. 각 바이너리 객체는 파일 형식(cle.Backend의 subclass)을 처리할 수 있는 loader backend에 의해 로드된다. 예를 들어, cle.ELF 는 ELF 바이너리 파일을 로드 하는 데 사용된다. 메모리에 로드된 바이너리 수 와 일치하지 않는 객체도 있을 것이며 예를 들어,  지원을 제공하는 데 사용되는 객체와 확인되지 않은 Symbols을 제공하는데 사용되는 외부 객체 CLE가  와 함께 로드한 전체 목록뿐만 아니라 다음과 같이 몇 가지 추가 표적 분류도 얻을 수있다. 해당 객체들과 직접 상호 작용하여 메타 데이터를 추출 할 수 있다. Symbols an…","fields":{"slug":"/angr-2_theori/"},"frontmatter":{"categories":"AnalyzingBinaries","title":"angr 바이너리 분석 활용 방안 2","date":"August 14, 2020"}},"next":{"fields":{"slug":"/angr-1_theori/"}},"previous":{"fields":{"slug":"/angr-3_theori/"}}},{"node":{"id":"5b569ddb-6945-54ec-b567-459680b3a2b7","excerpt":"프로젝트 선택 loader 이진 파일에서 가상 주소 공간에서 표현하는 것은 매우 복잡하다. 이를 처리하기 위하여 CLE 모듈이 있다. 로더라고 하는 CLE의 결과는 속성에서 사용할 수 있으며  프로그램과 함께 로드된 공유 라이버리를 보고 로드된 주소 공간에 대한 기본 쿼리를 숭행하는데 사용할 수 있다. p.factory (생성자들)  에는 많은 클래스가 있으며 대부분 프로젝트를 인스턴스화해야 한다. 모든 곳에서 프로젝트를 사용할 시 자주 사용하고 싶은 공통 객체에 대한 몇 가지 편리한 생성자를 제공한다.  block  주어진 주소에서 기본 코드 블록을 추출하는데 사용된다. state 객체는 프로그램의 “초기화 이미지” 만을 나타낸다.  로 실행을 수행할 때 시뮬레이션 된 프로그램 상태를 나타내는 특정 개체인  로 작업한다.  는 프로그램의 메모리, 레지스터, 파일 시스템 데이터를 포함하고 있다. 해당 값들은 파이썬의 정수가 아니다. 이다. 파이썬 정수는 CPU의 단어와 동일한 의미…","fields":{"slug":"/angr-1_theori/"},"frontmatter":{"categories":"AnalyzingBinaries","title":"angr 바이너리 분석 활용 방안 1","date":"August 14, 2020"}},"next":{"fields":{"slug":"/TWCTF_reversBOX_ctf_writeup/"}},"previous":{"fields":{"slug":"/angr-2_theori/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}