{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/CTF",
    "result": {"pageContext":{"currentCategory":"CTF","categories":["All","CTF","troubleshooting","AnalyzingBinaries","Mobile","Tools","Windows","Theory","Talk","Language"],"edges":[{"node":{"id":"093caa3f-71ec-5562-a741-87d4d08470d1","excerpt":"취약점 분석 Angry Bird 바이너리 동작 결과  바이너리 실행시 아무 결과가 안나오는 것을 확인할 수 있다. main 함수 분석   보호기법이 적용되어 있어 Stack Prlog를 거치면서  를  레지스터에 에서 생성된 값을 가져와 해당 값을 스택에 집어넣는 것을 확인할 수가 있으며  레지스터를 0으로 초기화 한후 0과 비교를 하여  함수로 점프하는 것을 볼 수 있다. 그래서, 해당 바이너리를 실행하였을 때 바로 끝나는 모습을 확인할 수 있다. Nop Sled 적용   Hex 값을 90(Nop)으로 패치하여 점프를 뛰어도 끝날 수 없도록 진행하였다.   디버거를 바탕으로  함수로 점프하는 것은 우회를 하여  문자열을 반환하는 것을 확인할 수있다. you should return 21 not 1 :( 출력된 결과를 확인해 보면 21을 반환해야 한다고 한다. 해당 함수를 분석해보도록 하겠다. Sub_4006F6 함수 분석  앞의 문자열을 출력한 함수 블록 내부이며 반환 되는 값 …","fields":{"slug":"/codegate2017_angrybird_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"CodeGate2017 angrybird 분석","date":"August 15, 2020"}},"next":{"fields":{"slug":"/docker_python_tbs/"}},"previous":null},{"node":{"id":"63ac0101-7bca-525d-8b12-a5fa8beb3168","excerpt":"바이너리 정보 main 함수 분석 Undefined (U) → Create String (a) → WOW String     인코딩되어진 값을 확인할 수 있다. 사용자 입력을 27바이트를 받으며  ~  까지 함수 호출 과정이 끝나고  를 호출하는 것을 확인할 수 있다. ptrace Anti-Debugging    함수는 인자  을 받으며 호출되며 반환 되는 값이  값 즉,  과 비교되어 0 이 아니게 되면 정상 루틴이 아닌 다른 루틴으로 빠지는 것을 확인할 수 있었다.  의  옵션은 자기 자신에게 디버거를 붙이라는 의미로서 해당 코드에서는 의 결과가 -1인지 검사하고 참이라면 유효하지 않은 코드 영역으로 점프를 하게 된다. 즉 안티 디버깅을 하기 위해  하는 것이다.  안티 디버깅 검사를 마친 후에 다시  ~  까지 함수를 이용하여 입력값 검증을 시도한다.   함수의 반환 값을 인자로 삼아  함수가 호출되는 것을 확인할 수 있으며,   함수를 바탕으로 rax레지스터 즉, 검증 함수…","fields":{"slug":"/codegate2018_redvelbet_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"CodeGate2018 RedVelvet write-up","date":"August 14, 2020"}},"next":{"fields":{"slug":"/sharkyCTF_z3z3_ctf_writeup/"}},"previous":{"fields":{"slug":"/droidCTF_droid_ctf_writeup/"}}},{"node":{"id":"eadfc36a-427f-5be4-b01b-4ce12d71c3c6","excerpt":"취약점 분석 바이너리 정보  바이너리 실행  입력 값을 받을 수 있도록 하며 임의의 문자열을 입력할 시  해당 문자열을 출력하는 것을 알 수 있다.    함수 호출 인자 , ,   함수 호출 인자 , ,  str1에 있는 문자열에서 str2 문자가 있을 경우 그 문자 까지의 개수를 리턴한다.  flag 값을 얻기 위해서는  함수를 거쳐서 반환 값이 1이어야 한다. 반환 값을 얻기 까지의 조건들이 너무 더럽다…  해당 조건을 디컴파일 한 결과 조건을 만족할 시 반환 되는 값은 1이다. 문제 제목 처럼 Z3를 통해 풀어보도록 하겠다. 해결 방안 SAT (Boolean SATisfiability problem) 주어진 Boolean 식을 충족시키는 해 (True로 표현되는 해)가 존재하는지 결정하는 문제 SAT는 명제논리식이기 때문에 각 변수에 True/False만 할당한다. 바이너리 정보 바이너리 실행","fields":{"slug":"/sharkyCTF_z3z3_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"Sharky CTF Z3 Robot","date":"August 14, 2020"}},"next":{"fields":{"slug":"/TWCTF_reversBOX_ctf_writeup/"}},"previous":{"fields":{"slug":"/codegate2018_redvelbet_ctf_writeup/"}}},{"node":{"id":"0438ec05-4e99-5375-bbc9-e6cabe5115be","excerpt":"취약점 분석 바이너리 정보 해당 바이너리를 올바른 플래그와 함께 실행했을 때의 아웃풀 정보를 보여준다.  main 함수 분석   형의  배열은  함수로 초기화가 되어지며 argv오 입력한 길이 만큼 루틴을 돌면서  의 인덱스 로 사용되어 해당 값을 출력한다. 인수를 사용하여 바이너리를 실행하는지 확인하고, 계산 함수를 호출하고 마지막으로 결과를 출력한다. 출력 형식을 보면 16진수 형식의 결과를 알 수 있다. init_table 함수 분석  do~while 문을 바탕으로 을 초기화한 후 나머지 의 값은 0번째 값을 이용해 생성하는 것을 확인할 수있다. 에 올 수 있는 경우의 수는 256이기 때문에 생성될 수있는 의 수도 256가지 이다. 시간을 난수 시드로 사용하며 경우의 수가 다수이다. 해당 어셈블리어를 살펴보도록 한다.  하위 2 비트, 즉 0-ff의 경우 다음 ROR1 계산 만 취해 보겠다. 이것은 알고리즘이며 다시 되돌리수 없다. 그렇기 때문에 블라스팅의 사용은 제한된다. …","fields":{"slug":"/TWCTF_reversBOX_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"TWCTF2016 ReverseBox 분석","date":"August 14, 2020"}},"next":{"fields":{"slug":"/angr-1_theori/"}},"previous":{"fields":{"slug":"/sharkyCTF_z3z3_ctf_writeup/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}