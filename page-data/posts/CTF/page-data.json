{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/CTF",
    "result": {"pageContext":{"currentCategory":"CTF","categories":["All","CTF","AnalyzingBinaries","troubleshooting","Mobile","Tools","Windows","Theory","Talk","Language"],"edges":[{"node":{"id":"8b2db8ca-f6eb-549e-abaf-e661c224717d","excerpt":"취약점 분석 Name\nmusicBlog Description\nYou can introduce favorite songs to friends with MusicBlog! File\nMusicBlog.tar.gz DockerFile 분석  PHP 7.4.0 버전을 사용하는 것을 확인할 수 있으며 해당 버전에 맞는 버그를 바탕으로 flag를 획득할 수 있겠다. 함수의  앞에 async 라는 예약어를 붙인후, 함수 내부에서 비동기 처리가 필요한 메서드에 await를 붙여준다. await 붙인 메서드는 비동기 처리 메서드가 꼭 promise 객체를 반환해야 await가 의도한 대로 동작한다. flag 문자열 찾기  flag 문자열을 검색하여  소스코드를 확인할 수 있다. 해당 코드를 보면 재선언, 재할당이 불가능하도록 설정되어 있다.  setUserAgent 메서드를 바탕으로 flag 값을 UserAgent로 설정하는 것을 확인할 수 있다. SamplePage   Sample Page 분석시…","fields":{"slug":"/zer0pts_music_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"zer0pts ctf 2020 - musicBlof 취약점 분석","date":"August 24, 2020"}},"next":{"fields":{"slug":"/hitcon2017_sakura_ctf_writeup/2020-08-16-HITCON2017-sakura/"}},"previous":null},{"node":{"id":"ef8ed1c7-9551-52fe-b73a-9e513ec3f2b6","excerpt":"취약점 분석 바이너리 실행 결과  입력 대기중 😑 바이너리 정보  main 함수 분석   번 루틴을 돌면서  함수를 바탕으로 입력을 받는다. 입력을 받을시 해당  버퍼를 사용하는데 해당 사이즈는 400바이트임을 계산할 수 있다.  루틴을 돌면서 400바이트 입력을 받은후 해당  를 인자로 하여  함수를 호출한후 해당 반환 값을 0이 아닐경우 FLAG 값을 출력하는 것을 확인할 수 있다. 출력 중간 사이에  함수가 보일텐데 해당 함수는  으로 해쉬화 하여 출력을 한다 즉, 해당 함수는 출력을 해쉬화 하는 과정이고 우리가 알아야 할 것은 어떤 걸 해쉬화를 하는지 입력 값을 바탕으로 어떤 조건을 통해 해쉬화 가되어지는지를 알아야 한다. sub_850 함수 분석 _start  _end  무려 시작과 끝의 옵셋 차이가 67493이 가 나는 함수 영역이다. …  처음 프롤로그 부분에서 스택 영역을  만큼이나 할당해준 후 무수히 많은 변수에 값을 대입하고 있다.  비슷한 구조로 한 블록에서 루…","fields":{"slug":"/hitcon2017_sakura_ctf_writeup/2020-08-16-HITCON2017-sakura/"},"frontmatter":{"categories":"CTF","title":"HitCon2017 Sakura 취약점 분석","date":"August 16, 2020"}},"next":{"fields":{"slug":"/elf_device_file3/"}},"previous":{"fields":{"slug":"/zer0pts_music_ctf_writeup/"}}},{"node":{"id":"093caa3f-71ec-5562-a741-87d4d08470d1","excerpt":"취약점 분석 Angry Bird 바이너리 동작 결과  바이너리 실행시 아무 결과가 안나오는 것을 확인할 수 있다. main 함수 분석   보호기법이 적용되어 있어 Stack Prlog를 거치면서  를  레지스터에 에서 생성된 값을 가져와 해당 값을 스택에 집어넣는 것을 확인할 수가 있으며  레지스터를 0으로 초기화 한후 0과 비교를 하여  함수로 점프하는 것을 볼 수 있다. 그래서, 해당 바이너리를 실행하였을 때 바로 끝나는 모습을 확인할 수 있다. Nop Sled 적용   Hex 값을 90(Nop)으로 패치하여 점프를 뛰어도 끝날 수 없도록 진행하였다.   디버거를 바탕으로  함수로 점프하는 것은 우회를 하여  문자열을 반환하는 것을 확인할 수있다. you should return 21 not 1 :( 출력된 결과를 확인해 보면 21을 반환해야 한다고 한다. 해당 함수를 분석해보도록 하겠다. Sub_4006F6 함수 분석  앞의 문자열을 출력한 함수 블록 내부이며 반환 되는 값 …","fields":{"slug":"/codegate2017_angrybird_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"CodeGate2017 angrybird 분석","date":"August 15, 2020"}},"next":{"fields":{"slug":"/docker_python_tbs/"}},"previous":{"fields":{"slug":"/elf_device_file4/"}}},{"node":{"id":"63ac0101-7bca-525d-8b12-a5fa8beb3168","excerpt":"바이너리 정보 main 함수 분석 Undefined (U) → Create String (a) → WOW String     인코딩되어진 값을 확인할 수 있다. 사용자 입력을 27바이트를 받으며  ~  까지 함수 호출 과정이 끝나고  를 호출하는 것을 확인할 수 있다. ptrace Anti-Debugging    함수는 인자  을 받으며 호출되며 반환 되는 값이  값 즉,  과 비교되어 0 이 아니게 되면 정상 루틴이 아닌 다른 루틴으로 빠지는 것을 확인할 수 있었다.  의  옵션은 자기 자신에게 디버거를 붙이라는 의미로서 해당 코드에서는 의 결과가 -1인지 검사하고 참이라면 유효하지 않은 코드 영역으로 점프를 하게 된다. 즉 안티 디버깅을 하기 위해  하는 것이다.  안티 디버깅 검사를 마친 후에 다시  ~  까지 함수를 이용하여 입력값 검증을 시도한다.   함수의 반환 값을 인자로 삼아  함수가 호출되는 것을 확인할 수 있으며,   함수를 바탕으로 rax레지스터 즉, 검증 함수…","fields":{"slug":"/codegate2018_redvelbet_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"CodeGate2018 RedVelvet write-up","date":"August 14, 2020"}},"next":{"fields":{"slug":"/sharkyCTF_z3z3_ctf_writeup/"}},"previous":{"fields":{"slug":"/droidCTF_droid_ctf_writeup/"}}},{"node":{"id":"eadfc36a-427f-5be4-b01b-4ce12d71c3c6","excerpt":"취약점 분석 바이너리 정보  바이너리 실행  입력 값을 받을 수 있도록 하며 임의의 문자열을 입력할 시  해당 문자열을 출력하는 것을 알 수 있다.    함수 호출 인자 , ,   함수 호출 인자 , ,  str1에 있는 문자열에서 str2 문자가 있을 경우 그 문자 까지의 개수를 리턴한다.  flag 값을 얻기 위해서는  함수를 거쳐서 반환 값이 1이어야 한다. 반환 값을 얻기 까지의 조건들이 너무 더럽다…  해당 조건을 디컴파일 한 결과 조건을 만족할 시 반환 되는 값은 1이다. 문제 제목 처럼 Z3를 통해 풀어보도록 하겠다. 해결 방안 SAT (Boolean SATisfiability problem) 주어진 Boolean 식을 충족시키는 해 (True로 표현되는 해)가 존재하는지 결정하는 문제 SAT는 명제논리식이기 때문에 각 변수에 True/False만 할당한다. 바이너리 정보 바이너리 실행","fields":{"slug":"/sharkyCTF_z3z3_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"Sharky CTF Z3 Robot","date":"August 14, 2020"}},"next":{"fields":{"slug":"/TWCTF_reversBOX_ctf_writeup/"}},"previous":{"fields":{"slug":"/codegate2018_redvelbet_ctf_writeup/"}}},{"node":{"id":"0438ec05-4e99-5375-bbc9-e6cabe5115be","excerpt":"취약점 분석 바이너리 정보 해당 바이너리를 올바른 플래그와 함께 실행했을 때의 아웃풀 정보를 보여준다.  main 함수 분석   형의  배열은  함수로 초기화가 되어지며 argv오 입력한 길이 만큼 루틴을 돌면서  의 인덱스 로 사용되어 해당 값을 출력한다. 인수를 사용하여 바이너리를 실행하는지 확인하고, 계산 함수를 호출하고 마지막으로 결과를 출력한다. 출력 형식을 보면 16진수 형식의 결과를 알 수 있다. init_table 함수 분석  do~while 문을 바탕으로 을 초기화한 후 나머지 의 값은 0번째 값을 이용해 생성하는 것을 확인할 수있다. 에 올 수 있는 경우의 수는 256이기 때문에 생성될 수있는 의 수도 256가지 이다. 시간을 난수 시드로 사용하며 경우의 수가 다수이다. 해당 어셈블리어를 살펴보도록 한다.  하위 2 비트, 즉 0-ff의 경우 다음 ROR1 계산 만 취해 보겠다. 이것은 알고리즘이며 다시 되돌리수 없다. 그렇기 때문에 블라스팅의 사용은 제한된다. …","fields":{"slug":"/TWCTF_reversBOX_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"TWCTF2016 ReverseBox 분석","date":"August 14, 2020"}},"next":{"fields":{"slug":"/angr-1_theori/"}},"previous":{"fields":{"slug":"/sharkyCTF_z3z3_ctf_writeup/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}