{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/CTF",
    "result": {"pageContext":{"currentCategory":"CTF","categories":["All","Windows","windows","1-day","CTF","AnalyzingBinaries","troubleshooting","Mobile","Tools","Theory","Talk","Language"],"edges":[{"node":{"id":"812e049c-90ef-548b-ab1c-ca8d05b7f5d2","excerpt":"취약점 분석 바이너리 개요 보호 기법 main 함수 분석   함수를 바탕으로 1.alloc, 2. free, 3. exit 조건을 수행하는 것을 확인할 수 있다. alloc  메모리 동적할당 과정을 확인해 보면 전역 포인터 배열  에 할당하는 것을 확인할 수 있으며 인덱스 범위가 총19개까지 할당이 가능하다. 사용자의 입력값이  이하까지 size로 할당이 되어지며 해당 사이즈 만큼 데이터를 입력 할 수 있다. free  free되는 과정을 확인해 보면 사용자의 입력 값이 곧 인덱스 범위로 사용되어 원하는 힙을 해제할 수 있으며 기본적인 길이 검증이 존재한다. 하지만 해제한 초인터를 초기화하지 않기 때문에 Double Free Bug가 발생한다. memory leak Idea 어떻게 하면 메모리 주소값을 릭할 수 있을 까? 힙 청크의 데이터를 출력하는 기능이 존재하지 않아 다른 방법을 찾아야 한다. _IO_FILE_stdout  파일 디스크립터는 출력할 때 주로 사용하며 구조체로 수…","fields":{"slug":"/d3ctf2019_new_heap_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"d3ctf 2019 new_heap 취약점 분석","date":"September 18, 2020"}},"next":{"fields":{"slug":"/csaw2019_travelle_ctf_writeup/"}},"previous":{"fields":{"slug":"/cve_2012_0002_1-day/"}}},{"node":{"id":"8880760b-3ccd-50c9-b8e4-3779cab3598b","excerpt":"취약점 분석 바이너리 개요 보호기법 main 함수 분석 argc 스택 주소가 노출되는 것을 확인할 수 있으며, 총 4개의 메뉴를 선택할 수 있다. Add 메뉴는 동적 할당을 진행한다. Change는 해당 할당되어진 값을 변경한다. Delete는 해제 Check는 할당된 값을 확인할 수 있다. add 함수 add func <1:0x80, 2:0x110, 3:0x128, 4:0x150, 5:0x200> size를 선택해서 그 사이즈를 통해 동적 할당 add func 마지막 tIndex 증가 배열 설정한 구조체 대입  change 함수 할당되어진 구조체의 destination 부분을 변경할 수 있으며 tIndex 부분을 사용자가 직접 입력하여 trips 구조체의 주소 부분에 접근이 가능하다. choice 가 tIndex보다 클경우 함수를 종료하는 제어 문이 존재 하지만 해당 함수에서는 취약한 점이 존재한다.  데이터 타입은 signed 이기 때문에 음수를 처리할 수 있다 그렇다면 해당 …","fields":{"slug":"/csaw2019_travelle_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"CSAW 2019 traveller 취약점 분석","date":"September 18, 2020"}},"next":{"fields":{"slug":"/midnightsun_gissa2_ctf_writeup/"}},"previous":{"fields":{"slug":"/d3ctf2019_new_heap_ctf_writeup/"}}},{"node":{"id":"527f840c-3346-5966-bbdf-58f7eb6e73ab","excerpt":"취약점 분석 바이너리 개요 보호기법  보호기법 NX PIE RELRO 바이너리 정보 바이너리 분석 메인 출력  메인 출력 부분 바이너리를 동작할 경우  문자열을 출력하면서 사용자의 입력 값을 받기 위해 대기 상태에 있는다. 사용자가 입력을 할 경우 만약 공백이면  문자열을 출력하면서 재 입력을 한며 카운터가 증가하지 않는다. 사용자가 입력을 할 경우 만약 입력 값이존재 한다면 어떤 로직을 바탕으로 검증을 하여 틀리게 되면  문자열을 출력하면서 카운터가 증가 한다. system call 추적  strace system call을 추적한 결과  함수가 ‘/home/ctf/flag’ 파일의 상태 여부와  함수를 바탕으로 읽기 전용으로 데이터를 읽어오는 것을 확인할 수 있다. 밑 분을 잘 보면  함수의 인자로  을 전달하여 seccom 보호 기법을 사용하는 것을 확인할 수 있으며  모드를 사용하여 블랙리스트 기반으로 접근제어를 하고 있다. SECCOMP_MODE_FILTER LIST da…","fields":{"slug":"/midnightsun_gissa2_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"Midnight sun 2019 gissa2 취약점 분석","date":"September 18, 2020"}},"next":{"fields":{"slug":"/csaw_small_boi_ctf_writeup/"}},"previous":{"fields":{"slug":"/csaw2019_travelle_ctf_writeup/"}}},{"node":{"id":"7aa9785d-9403-57d9-97d5-658045915602","excerpt":"취약점 분석 SROP 리눅스에서는 시그널이 들어오게 되면 커널 모드에서 처리한다. 커널 모드에서 유저모드로 들어오는 과정에서 유저의 스택에 레지스터 정보들을 저장해 놓는다.  은 이렇게 저장해놓은 정보들을 다시 돌려놓을 때 사용된다. 공격자가  시스템 콜을 호출할 수 있고 스택을 조작할 수 있다면 모든 레지스터와 > 세그먼트를 조작할 수 있다.  시스템 콜을 사용하여 익스폴로잇 하는 기법을 SigReturn Oriented Programming > (SROP)라고 한다. restore_sigcontext ,  매크로를 사용하여 레지스터및 세그먼트를 복원한다. sigcontext-32bit sigcontext-64bit 해당  구조체를 바탕으로 SROP 기법으 이용하여 공격을 진행할 수 있다. 문제 small_boi.c 문제 바이너리를 분석해 보면  , ,  등 익스를 하기에 필요한 명령들이 있는 것을 확인할 수 있으며 카니리 보호 기법이 걸려 있지 않아 버퍼 오버플로우를 발생시켜 …","fields":{"slug":"/csaw_small_boi_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"CSAW 2019 small_boi 취약점 분석","date":"September 18, 2020"}},"next":{"fields":{"slug":"/defcon2016_xkcd_ctf_writeup/"}},"previous":{"fields":{"slug":"/midnightsun_gissa2_ctf_writeup/"}}},{"node":{"id":"9a41bca5-49de-507b-a5a7-cc4a31a34f6d","excerpt":"취약점 분석  기타 정보 statically linked, 64 bit Heartbeat packet 보호기법 No RELRO No Canary found NX enabled No PIE 바이너리 분석 main 함수 분석  flag 파일의 내용을 읽어와 flag 변수에 집어넣는 것을 확인할 수 있다.  flag 변수는 .bss 섹션에 존재하며 전역 변수로 확인된다. 사용자의 입력 값을 토대로 특정 조건을 수행하게 되는데  함수를 바탕으로 문자 단위로 짤라 해당 문자열이 포함되는 지를 확인하고 있다.  strtok 그후 해당 부분에서  까지 잘라 해당 문자열의 값을  전역 변수에 memcpy를 하는 것을 확인할 수 있다.  globals 전역 변수  전역 변수는 총 512바이트이며, 같은 .bss 영역이므로 앞에서 선언된 flag와는 0x200차이가 나는 것을 확인할 수있다.  0x200 바이트 차이  비교 strtok   한 내부의 특 정 정수 값을 바탕으로  함수의 인자로 쓰이는…","fields":{"slug":"/defcon2016_xkcd_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"DEFCON 2016 xkcd 취약점 분석","date":"September 18, 2020"}},"next":{"fields":{"slug":"/defcon2016_feedme_ctf_writeup/"}},"previous":{"fields":{"slug":"/csaw_small_boi_ctf_writeup/"}}},{"node":{"id":"737b51b9-e824-5c9a-b633-806160194839","excerpt":"취약점 분석 바이너리 개요  보호 기법 stripped statically linked 32 bit 보호기법 No RELRO Canary found NX enabled PIE disabled 바이너리 분석  로직 분석1  바이너리의 입력 값으로  를  입력한 결과 SSP가 켜지는 것을 확인할 수 있으며 해당 바이너리에는 카나리가 존재하는 것을 확인할 수 있다.  로직 분석2 하지만  바이너리의 입력 값으로 를  번 입력한 결과 SSP 켜지지 않는 것으로 보아 앞의 첫 바이트의 입력 값이 해당 다음 입력 값 즉, 문자열의 길이 값이 되는 것을 추측할 수 있다.  systemcall system 호출 범위를 분석하던 중  시그널을 보낸 후  함수를 바탕으로  출력을 하는 것을 확인할 수 있으며 다시 자식 프로세스를 생성하는 것을 확인할 수 있다. 이로 인해 해당 바이너리는  함수를 바탕으로 자식 프로세스를 생성하는 로직을 확인할 수 있다. main 함수 분석  main 함수 분석 ma…","fields":{"slug":"/defcon2016_feedme_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"DEFCON 2016 feedme 취약점 분석","date":"September 18, 2020"}},"next":{"fields":{"slug":"/csaw_popping_ctf_writeup/"}},"previous":{"fields":{"slug":"/defcon2016_xkcd_ctf_writeup/"}}},{"node":{"id":"1de29c36-bdf1-5fda-b1dc-8d0f43ff9540","excerpt":"취약점 분석 바이너리 분석 바이너리 실행 결과 lib_system 주소가 노출되는 것을 확인할 수 있으며 4개의 옵션으로 해제 , 할당, 입력, 종료가 가능하다. 취약한 부분 메모리 주소 노출  lib_system 주소를 노출시키는 것을 확인할 수 있다. main 함수 부분  Bye 함수 부분  Exploit Idea 라이브러리 주소가 노출이되어 있기 때문에 해당 바이너리가 7가지 작업 만 수행 할 수 있으므로 작업을 낭비할 필요가 없다. 라이브러리 버전은 2.27 버전이며 tcache를 사용하고 있다. 바이너리 분석 결과 UAF를 직접적으로 가능하지 않기 때문에 tcache poisoning이 불가능 하다. 우리는 Double free buf를 바탕으로 tcache dup을 사용할 수 있다. 힙의 어느 위치에서나 해제가 가능하므로 tcache house of spirit을 사용할 수 있다. security check로 인해 작성하려는 위치에 fake chunk을 만들어야 한다. …","fields":{"slug":"/csaw_popping_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"CSAW 2019 popping_caps 취약점 분석","date":"September 18, 2020"}},"next":{"fields":{"slug":"/sstf2020_t_express_ctf_writeup/"}},"previous":{"fields":{"slug":"/defcon2016_feedme_ctf_writeup/"}}},{"node":{"id":"4d7e0722-1f4d-5af4-aa3e-9d121de77521","excerpt":"취약점 분석 바이너리 개요 보호기법  security check CANARY NX PIE RELRO 바이너리 정보 바이너리 분석 바이너리 로직 흐름  main output 총 4개의 메뉴를 선택할 수 있는 선택창을 확인할 수 있으며 , , ,  메뉴가 존재한다. Buy 메뉴  Buy 메뉴 두 가지 선택으로  ,  을 선택할 수 있으며, 입력 값은  ,  대입 되는 것으로 확인된다. 두 번째  은 출력 문에  옵션 값들이 기본 세팅되는 것으로 확인된다. View 메뉴 {: width=“60%” height=“60%“} View 메뉴 Use 메뉴 앞에서 입력한  들을 출력해주는 형식이며, 인덱스를 바탕으로 출력하는 것으로 보아 구조체 배열 구조임을 추측할 수 있다. {: width=“60%” height=“60%“} Use 메뉴 0 번째 인덱스를 선택한 결과  문자열이 출력되지만 1 번째 인덱스 같은 경우 구조체 멤버들의 값을 설정할 수 있는 옵션을 추가적으로 할 수 있다. 0 번째 …","fields":{"slug":"/sstf2020_t_express_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"SSTF 2020 t_express","date":"September 18, 2020"}},"next":{"fields":{"slug":"/zer0pts_music_ctf_writeup/"}},"previous":{"fields":{"slug":"/csaw_popping_ctf_writeup/"}}},{"node":{"id":"8b2db8ca-f6eb-549e-abaf-e661c224717d","excerpt":"취약점 분석 Name\nmusicBlog Description\nYou can introduce favorite songs to friends with MusicBlog! File\nMusicBlog.tar.gz DockerFile 분석  PHP 7.4.0 버전을 사용하는 것을 확인할 수 있으며 해당 버전에 맞는 버그를 바탕으로 flag를 획득할 수 있겠다. 함수의  앞에 async 라는 예약어를 붙인후, 함수 내부에서 비동기 처리가 필요한 메서드에 await를 붙여준다. await 붙인 메서드는 비동기 처리 메서드가 꼭 promise 객체를 반환해야 await가 의도한 대로 동작한다. flag 문자열 찾기  flag 문자열을 검색하여  소스코드를 확인할 수 있다. 해당 코드를 보면 재선언, 재할당이 불가능하도록 설정되어 있다.  setUserAgent 메서드를 바탕으로 flag 값을 UserAgent로 설정하는 것을 확인할 수 있다. SamplePage   Sample Page 분석시…","fields":{"slug":"/zer0pts_music_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"zer0pts ctf 2020 - musicBlof 취약점 분석","date":"August 24, 2020"}},"next":{"fields":{"slug":"/hitcon2017_sakura_ctf_writeup/2020-08-16-HITCON2017-sakura/"}},"previous":{"fields":{"slug":"/sstf2020_t_express_ctf_writeup/"}}},{"node":{"id":"ef8ed1c7-9551-52fe-b73a-9e513ec3f2b6","excerpt":"취약점 분석 바이너리 실행 결과  입력 대기중 😑 바이너리 정보  main 함수 분석   번 루틴을 돌면서  함수를 바탕으로 입력을 받는다. 입력을 받을시 해당  버퍼를 사용하는데 해당 사이즈는 400바이트임을 계산할 수 있다.  루틴을 돌면서 400바이트 입력을 받은후 해당  를 인자로 하여  함수를 호출한후 해당 반환 값을 0이 아닐경우 FLAG 값을 출력하는 것을 확인할 수 있다. 출력 중간 사이에  함수가 보일텐데 해당 함수는  으로 해쉬화 하여 출력을 한다 즉, 해당 함수는 출력을 해쉬화 하는 과정이고 우리가 알아야 할 것은 어떤 걸 해쉬화를 하는지 입력 값을 바탕으로 어떤 조건을 통해 해쉬화 가되어지는지를 알아야 한다. sub_850 함수 분석 _start  _end  무려 시작과 끝의 옵셋 차이가 67493이 가 나는 함수 영역이다. …  처음 프롤로그 부분에서 스택 영역을  만큼이나 할당해준 후 무수히 많은 변수에 값을 대입하고 있다.  비슷한 구조로 한 블록에서 루…","fields":{"slug":"/hitcon2017_sakura_ctf_writeup/2020-08-16-HITCON2017-sakura/"},"frontmatter":{"categories":"CTF","title":"HitCon2017 Sakura 취약점 분석","date":"August 16, 2020"}},"next":{"fields":{"slug":"/elf_device_file3/"}},"previous":{"fields":{"slug":"/zer0pts_music_ctf_writeup/"}}},{"node":{"id":"093caa3f-71ec-5562-a741-87d4d08470d1","excerpt":"취약점 분석 Angry Bird 바이너리 동작 결과  바이너리 실행시 아무 결과가 안나오는 것을 확인할 수 있다. main 함수 분석   보호기법이 적용되어 있어 Stack Prlog를 거치면서  를  레지스터에 에서 생성된 값을 가져와 해당 값을 스택에 집어넣는 것을 확인할 수가 있으며  레지스터를 0으로 초기화 한후 0과 비교를 하여  함수로 점프하는 것을 볼 수 있다. 그래서, 해당 바이너리를 실행하였을 때 바로 끝나는 모습을 확인할 수 있다. Nop Sled 적용   Hex 값을 90(Nop)으로 패치하여 점프를 뛰어도 끝날 수 없도록 진행하였다.   디버거를 바탕으로  함수로 점프하는 것은 우회를 하여  문자열을 반환하는 것을 확인할 수있다. you should return 21 not 1 :( 출력된 결과를 확인해 보면 21을 반환해야 한다고 한다. 해당 함수를 분석해보도록 하겠다. Sub_4006F6 함수 분석  앞의 문자열을 출력한 함수 블록 내부이며 반환 되는 값 …","fields":{"slug":"/codegate2017_angrybird_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"CodeGate2017 angrybird 분석","date":"August 15, 2020"}},"next":{"fields":{"slug":"/docker_python_tbs/"}},"previous":{"fields":{"slug":"/elf_device_file4/"}}},{"node":{"id":"63ac0101-7bca-525d-8b12-a5fa8beb3168","excerpt":"바이너리 정보 main 함수 분석 Undefined (U) → Create String (a) → WOW String     인코딩되어진 값을 확인할 수 있다. 사용자 입력을 27바이트를 받으며  ~  까지 함수 호출 과정이 끝나고  를 호출하는 것을 확인할 수 있다. ptrace Anti-Debugging    함수는 인자  을 받으며 호출되며 반환 되는 값이  값 즉,  과 비교되어 0 이 아니게 되면 정상 루틴이 아닌 다른 루틴으로 빠지는 것을 확인할 수 있었다.  의  옵션은 자기 자신에게 디버거를 붙이라는 의미로서 해당 코드에서는 의 결과가 -1인지 검사하고 참이라면 유효하지 않은 코드 영역으로 점프를 하게 된다. 즉 안티 디버깅을 하기 위해  하는 것이다.  안티 디버깅 검사를 마친 후에 다시  ~  까지 함수를 이용하여 입력값 검증을 시도한다.   함수의 반환 값을 인자로 삼아  함수가 호출되는 것을 확인할 수 있으며,   함수를 바탕으로 rax레지스터 즉, 검증 함수…","fields":{"slug":"/codegate2018_redvelbet_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"CodeGate2018 RedVelvet write-up","date":"August 14, 2020"}},"next":{"fields":{"slug":"/sharkyCTF_z3z3_ctf_writeup/"}},"previous":{"fields":{"slug":"/droidCTF_droid_ctf_writeup/"}}},{"node":{"id":"eadfc36a-427f-5be4-b01b-4ce12d71c3c6","excerpt":"취약점 분석 바이너리 정보  바이너리 실행  입력 값을 받을 수 있도록 하며 임의의 문자열을 입력할 시  해당 문자열을 출력하는 것을 알 수 있다.    함수 호출 인자 , ,   함수 호출 인자 , ,  str1에 있는 문자열에서 str2 문자가 있을 경우 그 문자 까지의 개수를 리턴한다.  flag 값을 얻기 위해서는  함수를 거쳐서 반환 값이 1이어야 한다. 반환 값을 얻기 까지의 조건들이 너무 더럽다…  해당 조건을 디컴파일 한 결과 조건을 만족할 시 반환 되는 값은 1이다. 문제 제목 처럼 Z3를 통해 풀어보도록 하겠다. 해결 방안 SAT (Boolean SATisfiability problem) 주어진 Boolean 식을 충족시키는 해 (True로 표현되는 해)가 존재하는지 결정하는 문제 SAT는 명제논리식이기 때문에 각 변수에 True/False만 할당한다. 바이너리 정보 바이너리 실행","fields":{"slug":"/sharkyCTF_z3z3_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"Sharky CTF Z3 Robot","date":"August 14, 2020"}},"next":{"fields":{"slug":"/TWCTF_reversBOX_ctf_writeup/"}},"previous":{"fields":{"slug":"/codegate2018_redvelbet_ctf_writeup/"}}},{"node":{"id":"0438ec05-4e99-5375-bbc9-e6cabe5115be","excerpt":"취약점 분석 바이너리 정보 해당 바이너리를 올바른 플래그와 함께 실행했을 때의 아웃풀 정보를 보여준다.  main 함수 분석   형의  배열은  함수로 초기화가 되어지며 argv오 입력한 길이 만큼 루틴을 돌면서  의 인덱스 로 사용되어 해당 값을 출력한다. 인수를 사용하여 바이너리를 실행하는지 확인하고, 계산 함수를 호출하고 마지막으로 결과를 출력한다. 출력 형식을 보면 16진수 형식의 결과를 알 수 있다. init_table 함수 분석  do~while 문을 바탕으로 을 초기화한 후 나머지 의 값은 0번째 값을 이용해 생성하는 것을 확인할 수있다. 에 올 수 있는 경우의 수는 256이기 때문에 생성될 수있는 의 수도 256가지 이다. 시간을 난수 시드로 사용하며 경우의 수가 다수이다. 해당 어셈블리어를 살펴보도록 한다.  하위 2 비트, 즉 0-ff의 경우 다음 ROR1 계산 만 취해 보겠다. 이것은 알고리즘이며 다시 되돌리수 없다. 그렇기 때문에 블라스팅의 사용은 제한된다. …","fields":{"slug":"/TWCTF_reversBOX_ctf_writeup/"},"frontmatter":{"categories":"CTF","title":"TWCTF2016 ReverseBox 분석","date":"August 14, 2020"}},"next":{"fields":{"slug":"/angr-1_theori/"}},"previous":{"fields":{"slug":"/sharkyCTF_z3z3_ctf_writeup/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}