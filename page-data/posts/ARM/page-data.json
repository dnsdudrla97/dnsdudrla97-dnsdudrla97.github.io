{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/ARM",
    "result": {"pageContext":{"currentCategory":"ARM","categories":["All","Blockchain","Solana","0-day","CLOUD","Web","projects","Talk","troubleshooting","Windows","AnalyzingBinaries","ARM","windows","1-day","CTF","Mobile","Tools","Theory","Language"],"edges":[{"node":{"id":"d9173485-2d4f-5176-b242-8d7c4167dd98","excerpt":"Store, Load Instruction ARM 방식에서 메모리간 데이터 처리 명령이 불가능하다. 레지스터와 메모리 간의 데이터 전송 명령어 를 사용해야 한다. Load Memory → Register Store Register → Memory  단일 레지스터 데이터 전송 LDR, STR, LDRB, STRB (size: WORD, BYTE) Pre, Post Index Addressing Pre-Index Method 데이터 전송 후 Base Register의 값은 변하지 않는다.  연산자를 붙이면 자동으로 주소를 업데이트 할 수 있다.  Post-Index Method 데이터 전송 후 Base Register와 Offset의 계산 결과가 Base Register에 적용된다.  연산 결과 Base Register인 r1 Register의 값이 0x100+0xc 의 값으로 변경된다. Store, Load Instruction Load Store 단일 레지스터 데이터 전송 Pre,…","fields":{"slug":"/arm-7/"},"frontmatter":{"categories":"ARM","title":"ARM data Transfer (POST,Pre-index Method, STR/LDR Instruction)","date":"February 10, 2021"}},"next":{"fields":{"slug":"/arm-8/"}},"previous":{"fields":{"slug":"/linked_list_/"}}},{"node":{"id":"e62d7b61-0989-52a1-8d5f-80625f86c8e8","excerpt":"LDR Rd, =const  의사 명령은 단일 명령어에서 32비트 숫자 상수를 생성할 수 있다. 이 의사 명령어를 사용하여 MOV, MVN 명령어 범위를 벗어난 상수를 생성한다. LDR 의사명령은 특정 상수에 대해 가장 효율적인 코드를 생성한다. MOV, MVN 명령어를 사용하여 상수를 생성 할 수 있는 경우 어셈블러는 적절한 명령어를 생성한다. MOV, MVN 명령어로 상수를 생성할 수 없는 경우 어셈블러는 다음을 수행한다. 값을 literal pool (상수 값을 유지하기 위해 코드에 포함된 메모리의 일부에 배치한다.) Literal pool에서 상수를 읽는 프로그램 기준 주소로 LDR 명령어를 생성한다. 어셈블러에서 생성한 LDR 명령어 범위 내에 리터럴 풀이 있는지 확인해야 한다. Literal pools 배치 어셈블러는 각 섹션의 끝에 리터럴 풀을 배치한다. 이들은 다음 섹션의 시작 부분에 있는 AREA instruction  또는 어셈블리 끝에 있는 END instruc…","fields":{"slug":"/arm-8/"},"frontmatter":{"categories":"ARM","title":"ARM LDR Rd, =const (constant)","date":"February 10, 2021"}},"next":{"fields":{"slug":"/arm-6/"}},"previous":{"fields":{"slug":"/arm-7/"}}},{"node":{"id":"bb13f006-b820-5125-b139-d5e5374efd82","excerpt":"레지스터에 상수 값 로드 메모리에서 데이터 로드를 수행하지 않고는 단일 명령어의 레지스터에 임의의 32비트 상수를 로드할 수 없다. ARM 명령어의 길이가 32 비트에 불과 하기 때문 Thumb 명령어에는 비슷한 제한이 걸려 있다. 데이터 로드와 함께 32 비트 값을 레지스터에 로드 할 수 있지만 일반적으로 사용되는 많은 상수를 로드하는 보다 직접적이고 효율적인 방법이 있다. 또한 일반적으로 사용되는 많은 상수를 별도의 로드 작업 없이 데이터 처리 명령어 내에서 피연산자로 직접 포함할 수 있다. 직접 로딩 MOV, MVN Instruction MOV Register MOV 명령은 모든 8 비트 상수 값을 로드 하여 0x0 ~ 0xFF (0-255) 범위를 제공한다. 또한 이러한 값을 짝수로 회전 할 수 도 있다. MVN Register MVN은 이러한 값의 비트 보수를 로드 할 수 있다. 숫자 값은  필요한 회전에 대해 계산할 필요가 없으며 어셈블러가 계산을 수행한다. MOV, M…","fields":{"slug":"/arm-6/"},"frontmatter":{"categories":"ARM","title":"ARM Register const load","date":"February 10, 2021"}},"next":{"fields":{"slug":"/arm-9/"}},"previous":{"fields":{"slug":"/arm-8/"}}},{"node":{"id":"365629df-f85a-55e7-b25c-6af021e4a887","excerpt":"Load, Store 다중 레지스터 명령 ARM, Thumb 명령어 집합에는 메모리에서 여러 레지스터를 로드하고 저장하는 명령어 가 포함되어 있다. 다중 레지스터 전송 명령어는 여러 레지스터의 내용을 메모리로부터 효율적으로 이동하는 방법을 제공한다. 블록 복사, 서브루틴 진입 및 종료시 스택 작업에 가장 자주 사용된다. 일련의 단일 데이터 전송 명령어 대신 다중 레지스터 전송 명령어를 사용하면 여러 이득이 있다. 코드의 크기를 작게 할 수 있다. 여러 명령 fetch가 아닌 단일 명령 fetch overhead 캐시되지 않은 ARM 프로세서에서 로드 또는 다중 저장에 의해 전송되는 첫 번째 워드는 항상 비 순차자적 메모리주기이지만 전송되는 모든 후속 word는 순차 메모리 주기 일 수 있다. 대부분의 시스템에서 순차적 메모리 주기가 더 빠르다. ARM LDM, STM 명령 여러 명령어를 로드, 저장 하면 단일 명령어를 사용하여 메모리에서 16개의 범용 레지스터의 하위 집합을 로드,…","fields":{"slug":"/arm-9/"},"frontmatter":{"categories":"ARM","title":"ARM Load,Store Multi Register Instruction","date":"February 10, 2021"}},"next":{"fields":{"slug":"/arm-5/"}},"previous":{"fields":{"slug":"/arm-6/"}}},{"node":{"id":"8c9e93e4-7a68-57de-9c83-92d41fc6d51a","excerpt":"레지스터에 주소 로드 레지스터에 주소를 로드해야 하는 경우가 종종 있다. 변수의 주소 값, 문자열 상수 또는 점프 테이블의 시작 위치… 주소는 일반적으로 현재 pc 또는 다른 레지스터의 오프셋으로 표현된다. 레지스터를 직접로드하려면 ADR, ADRL 을 사용한 직접로드 리터러 풀에서 주소 로드 (LDR, Rd, = label) ADR, ADRL 직접 로딩 ADR, ADRL 의사 명령어를 사용하면 데이터 로드를 수행하지 않고 특정 범위 내에서 주소를 생성할 수 있다. 선택적 오프셋이 있는 레이블 인 프로그램 기준 표현식 이며 여기서 레이블의 주소는 현재 PC에 상대적이다. 선택적 오프셋이 있는 레이블 인 레지스터 기준 식 이며 여기서 레이블의 주소는 지정된 범용 레지스터에 있는 주소에 상대적이다. 어셈블러는 다음을 생성하여  의사 명령어를 변환한다. 주소가 범위내에 있는 경우 주소를로드하는 단일 ADD, SUB 명령어 단일 명령어에서 주소에 도달할 수 없는 경우 오류 메시지 어셈블러…","fields":{"slug":"/arm-5/"},"frontmatter":{"categories":"ARM","title":"ARM Register Address load","date":"February 10, 2021"}},"next":{"fields":{"slug":"/arm-3/idnex/"}},"previous":{"fields":{"slug":"/arm-9/"}}},{"node":{"id":"55fcbec8-216b-594f-a9b8-ce43e46ab12e","excerpt":"37개의 레지스터가 있다. 레지스터는 부분적으로 겹치는 bank에 배열된다. 프로세서 모드마다 다른 레지스터 bank가 있다. bank 레지스터는 프로세서 예외 및 권한있는 작업을 처리하기 위한 빠른 문맥 교환을 제공한다.  범용 32 bit register 프로세서 모드에 따라 r0, r1, …, r13, r14와 같은 15개의 범용 레지스터가 한 번에 표시된다. R0 ~ R10은 범용 적으로 사용 R11 ~ R15특별한 목적으로 사용됨 r0 Register Return Value 저장 r0 ~ r3 Register 함수 호출 시에 Argument를 전달하는 용도로 사용 (인자가 4개 이상일시 스택을 사용) r11 Register 현재 스택 프레임의 Frame Pointer를 저장한다. r13 Register ARM 어셈블리 언에서 스택 포인터 (SP)로 쓰인다. C, C++ 컴파일러는 항상 r13을 스택 포인터로 사용한다. PUSH, POP 명령의 의해서 값이 변화한다. r14…","fields":{"slug":"/arm-3/idnex/"},"frontmatter":{"categories":"ARM","title":"ARM Register","date":"February 09, 2021"}},"next":{"fields":{"slug":"/arm-4/"}},"previous":{"fields":{"slug":"/arm-5/"}}},{"node":{"id":"0e362dd7-cb85-5cdb-b7e0-2076cd93b9e7","excerpt":"ARM Instruction Load/Store 구조 ARM에는 메모리 내에 데이터를 직접적으로 접근하는 것이 불가능하다. LDR, STR과 같은 명령을 통해서 메모리와 레지스터 사이에 데이터를 전송한다. 3-Address date Processing 두 개의 source operand, result operand ARM 모든 명령어는 조건부 실행 가능 모든 ARM 명령어는 CPSR의 ALU 상태 플래그 값에 대해 조건부로 실행될 수 있다. 일련의 명령어가 동일한 조건에 종속 될 때 더 좋을 수 있지만 조건부 명령어를 건너 뛰기 위해 분기를 사용할 필요가 없다. 데이터 처리 명령어가 이러한 플래그의 상태를 설정하는지 여부를 지정할 수 있다. 한 명령어로 설정된 플래그를 사용하여 그 사이에 많은 명령어가 있더라도 다른 명령어의 실행을 제어할 수 있다. Register Access ARM 상태에서 모든 명령어는 r0 ~ r14 에 액세스가 가능하다. 대부부은 r15(pc)에 대한 액세…","fields":{"slug":"/arm-4/"},"frontmatter":{"categories":"ARM","title":"ARM and THUMB Instruction","date":"February 09, 2021"}},"next":{"fields":{"slug":"/arm-2/"}},"previous":{"fields":{"slug":"/arm-3/idnex/"}}},{"node":{"id":"61af3ad2-c811-5f8f-afa0-f2fffa0d4177","excerpt":"ARM Conditional Execution Conditional Execution ARM 상태에서 각 데이터 처리 명령어에는 작업 결과에 따라 CPSR(Current Program State Register)의 ALU 상태 플래그를 업데이트 하는 옵션이 있다. ARM 데이터 처리 명령어에 S 접미사를 추가하여 CPSR에서 ALU 상태 플래그를 업데이트 한다. CMP, CMN, TST, TEQ에 S 접미사를 사용하면 안된다. 이러한 비교 명령어는 항상 플래그를 업데이트 하기 때문이다. Thumb 상태에서는 옵셥이 없다. MOV, ADD 명령어에서 하나 이상의 상위 레지스터가 사용되는 경우를 제외하고 모든 데이터 처리 명령어는 CPSR의 ALU 상태 플래그를 업데이트 한다. MOV 및 ADD는 이러한 경우 상태 플래그를 업데이트 할 수 없다. ARM 상태 수행 데이터 작업의 결과에 대해 CPSR의 ALU 상태 플래그를 업데이트 한다. 플래그를 업데이트 하지 않고 다른 여러 데이터 …","fields":{"slug":"/arm-2/"},"frontmatter":{"categories":"ARM","title":"ARM Conditional Execution","date":"February 09, 2021"}},"next":{"fields":{"slug":"/arm-0/"}},"previous":{"fields":{"slug":"/arm-4/"}}},{"node":{"id":"935223a9-cb61-500f-bacd-4c5f64777ab9","excerpt":"CISC (Complex Instruction Set Computer) 명령어가 복잡하여 명령어를 해석하는 데 시간이 오래 걸리며 명령어의 수가 많고 명령을 처리하는 시간이 길어 명령 처리 대기 시간이 길다. 명령어가 복잡하다? RISC (Reduced Instruction Set Computer) CPU 명령어의 개수를 줄여 하드웨어 구조를 좀 더 간단하게 만드는 방식 32비트로 명령어의 크기가 동일 하며 고정 길이를 갖는다. 명령어의 개수가 적다. 핵심적인 명령어를 기반으로 최소한의 명령어 집합을 구성하여 pipelining 기술을 도입하여 빠른 동작 속도와 하드웨어의 단순화와 효율성을 갖을 수 있으며 가격 경쟁령에서도 우위를 점하였다. ARM 에서 RISC 방식을 사용하는 이유 ARM은 Berkeley RISC에서 파생되었다. ARM Processor Operation Mode ARM 프로세서에는 총 7개의 동작 모드가 있다. 동작 모드는 프로세서가 어떠한 권한을 가지고 어떠…","fields":{"slug":"/arm-0/"},"frontmatter":{"categories":"ARM","title":"ARM hack overview","date":"February 09, 2021"}},"next":{"fields":{"slug":"/arm-1/"}},"previous":{"fields":{"slug":"/arm-2/"}}},{"node":{"id":"b8ba7110-bd58-55fc-9b7d-e2fd22b2ff00","excerpt":"ARM Instruction Layout label이 없더라도 명령어, 의사 명령어 및 지시어에는 공간이나 탭과 같은 공백이 선행되어야 한다. CASE Rule 명령어, 지시문 및 기호 레지스터 이름은 대문자 또는 소문자로 쓸 수 는 있지만 혼합 불가 Line Length Line이 길면  백 슬래시 문자를 바탕으로 여러 line으로 나누기 가능 백슬래시 뒤에는 다른 문자가 올 수 었다. Label 주소를 나타내는 기호이다. 레이블에 지정된 주소는 assembly 중에 계산된다. 어셈블러는 레이블이 정의 된 섹션의 원점을 기준으로 레이블의 주소를 계산한다. 동일한 섹션 내의 레이블에 대한 참조는 오프셋을 더하거나 뺀 프로그램 카운터를 사용할 수 있으며 이를 프로그램 기준 주소 지정이라고 한다. Local Label 지역 레이블은 레이블의 하위 클래스이다. 지역 레이블은 0-99 범위의 숫자로 시작한다. 다른 레이블과 달리 로컬 레이블은 여러 번 정의할 수 있다. 지역 레이블은 매크…","fields":{"slug":"/arm-1/"},"frontmatter":{"categories":"ARM","title":"ARM Assembly 1","date":"February 09, 2021"}},"next":{"fields":{"slug":"/window_5_theori/"}},"previous":{"fields":{"slug":"/arm-0/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}