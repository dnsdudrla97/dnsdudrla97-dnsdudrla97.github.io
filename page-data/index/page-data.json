{
    "componentChunkName": "component---src-pages-index-js",
    "path": "/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"c04c445f-740b-5681-976e-b1cbd901859a","excerpt":"2020년에 진행했던 Hack the Challenge 대회에 참여하면서 취약점 제보 과정을 통해 접하게 되었었습니다. 저의 생각으로 국내 버그 바운티 프로그램으로 KISA 보안 취약점 제보 서비스, 각 메이저한 기업에서 하는 곳을 제외하고는 찾아보긴 힘들었지만, 삼성 SDS 해킹 존을 새롭게 접하게 되었습니다.  해킹존 버그바운티 플랫폼 서비스는 해당 사진과 같이 취약점 점검이 필요한 기업들이 나열되어 있으며 취약점 점검 시 발견한 유효 취약점 최대 포상 금액이 명시되어 있어 화이트 해커들이 쉽게 파악할 수 있습니다. 또한, 자신의 분야와 관련된 분석을 진행할 수 있도록 태그로 명시되어 있어 직접 들어가 보지 않아도 빠르게 파악할 수 있습니다. 이처럼 사용자에게 친숙한 UI/UX를 제공함으로써 접근성이 좋아 만족도가 높습니다. 유효 취약점을 발견한다면 정해진 포상 금액과 포인트를 받게 됩니다. 해당 포인트 제도는 옆의 리포터 순위에 명시된 것처럼 순위 제도를 운용하여 화이트 해커…","frontmatter":{"categories":"Talk","title":"버그바운티 플랫폼 HackingZone 리뷰","date":"July 01, 2021"},"fields":{"slug":"/hackingzone_event/"}}},{"node":{"id":"82753a26-e8cc-5cd4-ba38-12e5ae3275a6","excerpt":"윈도우 하이퍼바이저 Ubuntu 20.04 VM 윈도우 하이버바이저 기능 설정 후  윈도우 하이버바이저 관리자  하이퍼관라자  에서  선택후 가상 컴퓨터 만들기 창으로 이동  선택후 가상 컴퓨터 만들기 클릭 후 대기  설치 완료후 Ubuntu 부팅 완료 Ubuntu VM Full screen 설정 방법 grub 설정 파일 편집  line 10 편집  설정 편집후 업데이트 명령 실행  재부팅 전체 화면 설정 완료  윈도우 하이버바이저 기능 설정 후 윈도우 하이버바이저 관리자 Ubuntu VM Full screen 설정 방법 전체 화면 설정 완료","frontmatter":{"categories":"troubleshooting","title":"윈도우 하이버파이저 Ubuntu 20.04 전체 화면 설정 (오류 해결)","date":"April 01, 2021"},"fields":{"slug":"/window_hyper-V_tbs/"}}},{"node":{"id":"72b9319f-7315-5e0f-bd90-3520d10bacff","excerpt":"Window Heap Management  메모리 할당 방식이 상위일경우 더 높은 수준의 구현을 사용한다. Kernel-Mode Memory Manager 운영 체제에 대한 모든 메모리 예약 및 할당 메모리 매핑 파일 공유 메모리 쓰기 작업 복사 사용자 모드에서 직접 접근 불가 VirtualAlloc/VirtualFree User Mode 에서 사용할 수 있는 가장 낮은 수준의 API  를 호출하고 해당 기능을 바탕으로 빠른 SYSCALL을  으로 호출하여 추가 처리를 커널 메모리 관리자에 다시 할당한다. 두 가지 주요 조건  경계에 정렬된 메모리 블록만 할당할 수 있다. 의 배수인 크기의 메모리 블록만 할당할 수 있다. 시스템 세분화  에 호출시 해당 정보를 받을 수 있는데  매개 변수로 반환된다. 해당 값의 구현(및 하드웨어)에 따라 달라지지만 64bit Window System에서는 0x10000 바이트 또는 64kb로 설정된다. 즉, 시스템 세분화는  다음과 같이 8바이트 …","frontmatter":{"categories":"Windows","title":"윈도우 힙 관리자","date":"March 30, 2021"},"fields":{"slug":"/window_allocator_/"}}},{"node":{"id":"c94eebc9-2dc9-597a-8025-5b9589abfbd6","excerpt":"Linekd List Node, Element 리스트의 데이터 각각의 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 있다. 처음, 끝 부분은 각자만의 ,  갖는다. 한 노드 바로 앞에 있는 노드는  한 노드 바로 뒤에 있는 노드는  연결리스트 구성 데이터를 연결 리스트에 삽입할 때 노드용 객체를 만든다. 삭제할 때 노드용 객체를 없애면 데이터 추가 삭제를 효율적으로 할 수 있다.  Self-referential 형(자기 자신과 같은 자료형의 객체를 가리크는 데이터를 가지고 있는 자료구조) Tail Node는 next node를 갖지 않기 때문에 next 값은 (NULL) 값을 대입한다. 소스 코드 nodeAlloc 함수 Node 형 객체를 만들고 만든 객체의 포인터를 반환한다. setNode 함수 노드의 멤버 값을 설정 Node형 객체의 두 멈베(data, next)의 값을 설정하는 함수 첫 번째 매개 변수 n으로 전달받은 포인터가 가리키는 Node 형 객체에 x가 가리키는…","frontmatter":{"categories":"AnalyzingBinaries","title":"연결 리스트 구조 공격 벡터 선정 (Intel arch)","date":"March 01, 2021"},"fields":{"slug":"/linked_list_/"}}},{"node":{"id":"8ce1dc62-0ab8-5138-bf09-db9c27deda56","excerpt":"Load, Store 다중 레지스터 명령 ARM, Thumb 명령어 집합에는 메모리에서 여러 레지스터를 로드하고 저장하는 명령어 가 포함되어 있다. 다중 레지스터 전송 명령어는 여러 레지스터의 내용을 메모리로부터 효율적으로 이동하는 방법을 제공한다. 블록 복사, 서브루틴 진입 및 종료시 스택 작업에 가장 자주 사용된다. 일련의 단일 데이터 전송 명령어 대신 다중 레지스터 전송 명령어를 사용하면 여러 이득이 있다. 코드의 크기를 작게 할 수 있다. 여러 명령 fetch가 아닌 단일 명령 fetch overhead 캐시되지 않은 ARM 프로세서에서 로드 또는 다중 저장에 의해 전송되는 첫 번째 워드는 항상 비 순차자적 메모리주기이지만 전송되는 모든 후속 word는 순차 메모리 주기 일 수 있다. 대부분의 시스템에서 순차적 메모리 주기가 더 빠르다. ARM LDM, STM 명령 여러 명령어를 로드, 저장 하면 단일 명령어를 사용하여 메모리에서 16개의 범용 레지스터의 하위 집합을 로드,…","frontmatter":{"categories":"ARM","title":"ARM Load,Store Multi Register Instruction","date":"February 10, 2021"},"fields":{"slug":"/arm-9/"}}},{"node":{"id":"284f8c50-2a44-55c2-8393-66eae707c7ec","excerpt":"LDR Rd, =const  의사 명령은 단일 명령어에서 32비트 숫자 상수를 생성할 수 있다. 이 의사 명령어를 사용하여 MOV, MVN 명령어 범위를 벗어난 상수를 생성한다. LDR 의사명령은 특정 상수에 대해 가장 효율적인 코드를 생성한다. MOV, MVN 명령어를 사용하여 상수를 생성 할 수 있는 경우 어셈블러는 적절한 명령어를 생성한다. MOV, MVN 명령어로 상수를 생성할 수 없는 경우 어셈블러는 다음을 수행한다. 값을 literal pool (상수 값을 유지하기 위해 코드에 포함된 메모리의 일부에 배치한다.) Literal pool에서 상수를 읽는 프로그램 기준 주소로 LDR 명령어를 생성한다. 어셈블러에서 생성한 LDR 명령어 범위 내에 리터럴 풀이 있는지 확인해야 한다. Literal pools 배치 어셈블러는 각 섹션의 끝에 리터럴 풀을 배치한다. 이들은 다음 섹션의 시작 부분에 있는 AREA instruction  또는 어셈블리 끝에 있는 END instruc…","frontmatter":{"categories":"ARM","title":"ARM LDR Rd, =const (constant)","date":"February 10, 2021"},"fields":{"slug":"/arm-8/"}}},{"node":{"id":"282d47b4-96d2-5ef3-b231-8485022b3a5d","excerpt":"레지스터에 주소 로드 레지스터에 주소를 로드해야 하는 경우가 종종 있다. 변수의 주소 값, 문자열 상수 또는 점프 테이블의 시작 위치… 주소는 일반적으로 현재 pc 또는 다른 레지스터의 오프셋으로 표현된다. 레지스터를 직접로드하려면 ADR, ADRL 을 사용한 직접로드 리터러 풀에서 주소 로드 (LDR, Rd, = label) ADR, ADRL 직접 로딩 ADR, ADRL 의사 명령어를 사용하면 데이터 로드를 수행하지 않고 특정 범위 내에서 주소를 생성할 수 있다. 선택적 오프셋이 있는 레이블 인 프로그램 기준 표현식 이며 여기서 레이블의 주소는 현재 PC에 상대적이다. 선택적 오프셋이 있는 레이블 인 레지스터 기준 식 이며 여기서 레이블의 주소는 지정된 범용 레지스터에 있는 주소에 상대적이다. 어셈블러는 다음을 생성하여  의사 명령어를 변환한다. 주소가 범위내에 있는 경우 주소를로드하는 단일 ADD, SUB 명령어 단일 명령어에서 주소에 도달할 수 없는 경우 오류 메시지 어셈블러…","frontmatter":{"categories":"ARM","title":"ARM Register Address load","date":"February 10, 2021"},"fields":{"slug":"/arm-5/"}}},{"node":{"id":"83332853-144f-55d5-8978-4be25939a56c","excerpt":"레지스터에 상수 값 로드 메모리에서 데이터 로드를 수행하지 않고는 단일 명령어의 레지스터에 임의의 32비트 상수를 로드할 수 없다. ARM 명령어의 길이가 32 비트에 불과 하기 때문 Thumb 명령어에는 비슷한 제한이 걸려 있다. 데이터 로드와 함께 32 비트 값을 레지스터에 로드 할 수 있지만 일반적으로 사용되는 많은 상수를 로드하는 보다 직접적이고 효율적인 방법이 있다. 또한 일반적으로 사용되는 많은 상수를 별도의 로드 작업 없이 데이터 처리 명령어 내에서 피연산자로 직접 포함할 수 있다. 직접 로딩 MOV, MVN Instruction MOV Register MOV 명령은 모든 8 비트 상수 값을 로드 하여 0x0 ~ 0xFF (0-255) 범위를 제공한다. 또한 이러한 값을 짝수로 회전 할 수 도 있다. MVN Register MVN은 이러한 값의 비트 보수를 로드 할 수 있다. 숫자 값은  필요한 회전에 대해 계산할 필요가 없으며 어셈블러가 계산을 수행한다. MOV, M…","frontmatter":{"categories":"ARM","title":"ARM Register const load","date":"February 10, 2021"},"fields":{"slug":"/arm-6/"}}},{"node":{"id":"e856ff42-187b-5bf3-8b78-b241b012f797","excerpt":"Store, Load Instruction ARM 방식에서 메모리간 데이터 처리 명령이 불가능하다. 레지스터와 메모리 간의 데이터 전송 명령어 를 사용해야 한다. Load Memory → Register Store Register → Memory  단일 레지스터 데이터 전송 LDR, STR, LDRB, STRB (size: WORD, BYTE) Pre, Post Index Addressing Pre-Index Method 데이터 전송 후 Base Register의 값은 변하지 않는다.  연산자를 붙이면 자동으로 주소를 업데이트 할 수 있다.  Post-Index Method 데이터 전송 후 Base Register와 Offset의 계산 결과가 Base Register에 적용된다.  연산 결과 Base Register인 r1 Register의 값이 0x100+0xc 의 값으로 변경된다. Store, Load Instruction Load Store 단일 레지스터 데이터 전송 Pre,…","frontmatter":{"categories":"ARM","title":"ARM data Transfer (POST,Pre-index Method, STR/LDR Instruction)","date":"February 10, 2021"},"fields":{"slug":"/arm-7/"}}},{"node":{"id":"dea513df-6e74-569a-97e0-21c523a09715","excerpt":"ARM Conditional Execution Conditional Execution ARM 상태에서 각 데이터 처리 명령어에는 작업 결과에 따라 CPSR(Current Program State Register)의 ALU 상태 플래그를 업데이트 하는 옵션이 있다. ARM 데이터 처리 명령어에 S 접미사를 추가하여 CPSR에서 ALU 상태 플래그를 업데이트 한다. CMP, CMN, TST, TEQ에 S 접미사를 사용하면 안된다. 이러한 비교 명령어는 항상 플래그를 업데이트 하기 때문이다. Thumb 상태에서는 옵셥이 없다. MOV, ADD 명령어에서 하나 이상의 상위 레지스터가 사용되는 경우를 제외하고 모든 데이터 처리 명령어는 CPSR의 ALU 상태 플래그를 업데이트 한다. MOV 및 ADD는 이러한 경우 상태 플래그를 업데이트 할 수 없다. ARM 상태 수행 데이터 작업의 결과에 대해 CPSR의 ALU 상태 플래그를 업데이트 한다. 플래그를 업데이트 하지 않고 다른 여러 데이터 …","frontmatter":{"categories":"ARM","title":"ARM Conditional Execution","date":"February 09, 2021"},"fields":{"slug":"/arm-2/"}}},{"node":{"id":"689cb3e5-6e23-58b9-979b-f7091b4eea2c","excerpt":"CISC (Complex Instruction Set Computer) 명령어가 복잡하여 명령어를 해석하는 데 시간이 오래 걸리며 명령어의 수가 많고 명령을 처리하는 시간이 길어 명령 처리 대기 시간이 길다. 명령어가 복잡하다? RISC (Reduced Instruction Set Computer) CPU 명령어의 개수를 줄여 하드웨어 구조를 좀 더 간단하게 만드는 방식 32비트로 명령어의 크기가 동일 하며 고정 길이를 갖는다. 명령어의 개수가 적다. 핵심적인 명령어를 기반으로 최소한의 명령어 집합을 구성하여 pipelining 기술을 도입하여 빠른 동작 속도와 하드웨어의 단순화와 효율성을 갖을 수 있으며 가격 경쟁령에서도 우위를 점하였다. ARM 에서 RISC 방식을 사용하는 이유 ARM은 Berkeley RISC에서 파생되었다. ARM Processor Operation Mode ARM 프로세서에는 총 7개의 동작 모드가 있다. 동작 모드는 프로세서가 어떠한 권한을 가지고 어떠…","frontmatter":{"categories":"ARM","title":"ARM hack overview","date":"February 09, 2021"},"fields":{"slug":"/arm-0/"}}},{"node":{"id":"d3e1bf44-a8a2-5d02-8147-56572f1bfc40","excerpt":"37개의 레지스터가 있다. 레지스터는 부분적으로 겹치는 bank에 배열된다. 프로세서 모드마다 다른 레지스터 bank가 있다. bank 레지스터는 프로세서 예외 및 권한있는 작업을 처리하기 위한 빠른 문맥 교환을 제공한다.  범용 32 bit register 프로세서 모드에 따라 r0, r1, …, r13, r14와 같은 15개의 범용 레지스터가 한 번에 표시된다. R0 ~ R10은 범용 적으로 사용 R11 ~ R15특별한 목적으로 사용됨 r0 Register Return Value 저장 r0 ~ r3 Register 함수 호출 시에 Argument를 전달하는 용도로 사용 (인자가 4개 이상일시 스택을 사용) r11 Register 현재 스택 프레임의 Frame Pointer를 저장한다. r13 Register ARM 어셈블리 언에서 스택 포인터 (SP)로 쓰인다. C, C++ 컴파일러는 항상 r13을 스택 포인터로 사용한다. PUSH, POP 명령의 의해서 값이 변화한다. r14…","frontmatter":{"categories":"ARM","title":"ARM Register","date":"February 09, 2021"},"fields":{"slug":"/arm-3/idnex/"}}},{"node":{"id":"e1eaf522-a7ae-5891-b24b-a7ba56d96bf6","excerpt":"ARM Instruction Load/Store 구조 ARM에는 메모리 내에 데이터를 직접적으로 접근하는 것이 불가능하다. LDR, STR과 같은 명령을 통해서 메모리와 레지스터 사이에 데이터를 전송한다. 3-Address date Processing 두 개의 source operand, result operand ARM 모든 명령어는 조건부 실행 가능 모든 ARM 명령어는 CPSR의 ALU 상태 플래그 값에 대해 조건부로 실행될 수 있다. 일련의 명령어가 동일한 조건에 종속 될 때 더 좋을 수 있지만 조건부 명령어를 건너 뛰기 위해 분기를 사용할 필요가 없다. 데이터 처리 명령어가 이러한 플래그의 상태를 설정하는지 여부를 지정할 수 있다. 한 명령어로 설정된 플래그를 사용하여 그 사이에 많은 명령어가 있더라도 다른 명령어의 실행을 제어할 수 있다. Register Access ARM 상태에서 모든 명령어는 r0 ~ r14 에 액세스가 가능하다. 대부부은 r15(pc)에 대한 액세…","frontmatter":{"categories":"ARM","title":"ARM and THUMB Instruction","date":"February 09, 2021"},"fields":{"slug":"/arm-4/"}}},{"node":{"id":"bccb7d0b-fe4e-5c4a-80d0-e733f5338197","excerpt":"ARM Instruction Layout label이 없더라도 명령어, 의사 명령어 및 지시어에는 공간이나 탭과 같은 공백이 선행되어야 한다. CASE Rule 명령어, 지시문 및 기호 레지스터 이름은 대문자 또는 소문자로 쓸 수 는 있지만 혼합 불가 Line Length Line이 길면  백 슬래시 문자를 바탕으로 여러 line으로 나누기 가능 백슬래시 뒤에는 다른 문자가 올 수 었다. Label 주소를 나타내는 기호이다. 레이블에 지정된 주소는 assembly 중에 계산된다. 어셈블러는 레이블이 정의 된 섹션의 원점을 기준으로 레이블의 주소를 계산한다. 동일한 섹션 내의 레이블에 대한 참조는 오프셋을 더하거나 뺀 프로그램 카운터를 사용할 수 있으며 이를 프로그램 기준 주소 지정이라고 한다. Local Label 지역 레이블은 레이블의 하위 클래스이다. 지역 레이블은 0-99 범위의 숫자로 시작한다. 다른 레이블과 달리 로컬 레이블은 여러 번 정의할 수 있다. 지역 레이블은 매크…","frontmatter":{"categories":"ARM","title":"ARM Assembly 1","date":"February 09, 2021"},"fields":{"slug":"/arm-1/"}}},{"node":{"id":"4cf4f426-dd33-58b3-8144-d8b530eeb3e9","excerpt":"window NT 데이터 구조체 이며 프로세스 정보를 담고 있는 구조체 PEB 접근 방법 TEB.ProcessEnvironmentBlock 멤버가 PEB 구조체의 주소 TEB 구조체는 FS 세그먼트 셀렉터가 가리키는 세그먼트 메모리의 base address에 위치한다. 그리고 ProcessEnvironmentBlock 멤버는 TEB 구조체 시작 부터 30 옵셋만큼 떨어져 있다. method 1 바로 PEB 주소를 구하는 방법 method 2 TEB 주소를 구한후 ProcessEnvironmentBlock 멤버를 이용  FS:[0x30] 주소 값을 확인할 수 있다. PEB 구조체 정의 PEB.BeingDebugged Kernel32!IsDebuggerPresent() API 현재 프로세스가 디버깅을 당하는지를 판단해서 결과를 반환한다. API가 참조하는 정보가 바로 PEB.BeingDebugged 멤버이다. (디버깅 중이면1, 아니면 0을 반환) PEB.ImageBaseAddress…","frontmatter":{"categories":"Windows","title":"PEB (Process Environment Block)","date":"January 03, 2021"},"fields":{"slug":"/window_1_theori/"}}},{"node":{"id":"2e45e35c-08cd-5d0d-ae8a-ba3131d41d4d","excerpt":"SEH  는 각 Thread와 관련된  구성된다. 원칙적으로 해당 목록의 노드는 stack에 할당된다. 목록의 Head는 TEB(Thred Environment Block)의 시작 부분에 있는 포인터로 가리키므로 코드가 새 예외처리기를 추가하려는 경우 새 노드가 목록의 헤드와 포인터에 추가된다. TEB에서 새 노드를 가리키도록 변경된다. 각 노드는  유형이며 핸들러의 주소와 목록의 다음 노드에 대한 포인터를 저장한다. 이상하게도 목록의 마지막 노드의 “next pointer” 는 NULL이 아니지만  와 같다. TEB는 FS:[0] 부터 시작하는  FS를 통해서도 액세스 할 수 있으므로 다음과 같은 코드르 보는 것이 일반적이다. 컴파일러는 일반적으로 프로그램의 어느 영역이 실행되고 있는지 (전역 변수에 의존) 알고 호출될 될 때 그에 따라 동작하는 단일 전역 처리기를 등록한다. 각 스레드에는 다른  가 있으므로 운영 체제는  에 의해 선택된 세그먼트가 항상 올바른 TEB(즉, 현재…","frontmatter":{"categories":"Windows","title":"Windows SEH (Structured Exception Handler) 1","date":"January 03, 2021"},"fields":{"slug":"/window_2_theori/"}}},{"node":{"id":"4164e698-1c6e-58a5-b3ee-a5374a38ba82","excerpt":"SEH (Structured Exception Handler) SEH Windows 운영체제에서 제공하는 예외처리 시스템이다.  키워드로 간단히 구현할 수 있다. 하드웨어 오류와 같은 특정 예외 코드 상황을 정상적으로 처리하기 위해 C에 대한 Microsoft 확장이다. SEH를 사용하면 실행이 예기치 않게 종료 되는 경우 메모리 블록 및 파일과 같은 리소스가 올바르게 해제 되도록 할 수 있다. SEH 매커니즘 예외 처리기 ,  예외에 응답 하거나 해제할 수 있는 블록 Termination Handlers  예외가 종료를 발생 시키는 지 여부에 관계 없이 항상 호출되는 종료 처리기 또는 블록 일반 실행의 경우 예외 처리 방법 OS는 프로세스 실행 중에 예외가 발생하면 프로세스에게 처리를 맡긴다. 프로세스 코드에 (SEH…) 예외처 리가 구현되어 있다면, 해당 예외를 잘 처리한 후 게속 실행될 것이다. 구현되어 있지 않다면 기본 예외 처리기를 동작시켜 프로세스를 종료 시킨다. 디버깅…","frontmatter":{"categories":"Windows","title":"Windows SEH (Structured Exception Handler) 0","date":"January 03, 2021"},"fields":{"slug":"/window_3_theori/"}}},{"node":{"id":"221bd0db-e02b-58bb-9a44-6e40646b30e7","excerpt":"TEB (Thread Environment Block) 프로세스에서 실행되는 스레드에 대한 정보를 담고 있는 구조체 스레드별로 TEB 구조체가 하나씩 할당된다. OS 종류별로 해당 모양이 조금씩 달라진다. ProcessEnvironmentBlock member 0x30 offset 에 위치한 ProcessEnvironmentBlock member PEB(Process Environment Block) 구조체의 포인터이다. PEB는 프로세스 별로 하나만 생성된다. NtTib member TEB 구조체의 첫 번째 멤버는  구조체이다. _NT_TIB (_NT_Thread information Block) 현재 실행 중인 스레드에 대한 정보를 저장하고 있다. ExceptionList member는 _EXCEPTION_REGISTRATION_RECORD 구조체 연결 리스트를 가리키고 있다. 이것은 SEH(Structured Exception Handler) 라고 하는 Window OS의 예…","frontmatter":{"categories":"Windows","title":"TEB (Thread Environment Block)","date":"January 03, 2021"},"fields":{"slug":"/window_4_theori/"}}},{"node":{"id":"d9819043-fd75-5e98-89fc-f65dcd88ada0","excerpt":"Thread Local Storage (TLS) 프로세스의 모든 스레드는 가상 주소 공간을 공유한다. 함수의 지역 변수는 함수를 실행하는 각 스레드에 공유한다. 정적 및 전역 변수는 프로세스의 모든 스레드에서 공유된다. 즉, 스레드 별로 독립된 데이터 저장 공간이며 스레드 내에서 프로세스의 전역(Global) 데이터나 정적(static) 데이터를 마치 지역(Local) 데이터 처럼 독립적으로 취급하고 싶을 때 사용한다.  IMAGE_DATA_DIRECTORY[9] PE 헤더의 TLS Table 항목이 세팅된다. IMAGE_NT_HEADERS - IMAGE_OPTIONAL_HEADER - IMAGE_DATA_DIRECTORY[9] {: width=“65%” height=“65%“} RVA 01AAF3A0 주소에는 IMAGE_TLS_DIRECTORY 구조체가 있다. IMAGE_TLS_DIRECTORY IMAGE_TLS_DIRECTORY 구조체는 x86/x64 bit로 설계되어 있다. …","frontmatter":{"categories":"Windows","title":"TLS(Thread Local Storage CallBack)","date":"January 03, 2021"},"fields":{"slug":"/window_5_theori/"}}},{"node":{"id":"57d8c503-44bf-5e63-b7dc-21c220cacb79","excerpt":"Fuzz Fuzzing or fuzz testing is an automated software testing technique that involves providing invalid, unexpected, or random data as inputs to a computer program. The program is then monitored for exceptions such as crashes, failing built-in code assertions, or potential memory leaks. Typically, fuzzers are used to test programs that take structured inputs. This structure is specified, e.g., in a file format or protocol and distinguishes valid from invalid input. An effective fuzzer generates…","frontmatter":{"categories":"projects","title":"Development of window GUI binary fuzzing using the dump fuzzing theory.","date":"December 20, 2020"},"fields":{"slug":"/project_fuzz_/"}}},{"node":{"id":"74aeb365-aacf-5fdf-b30f-88959a928ba3","excerpt":"취약점 분석 보고서 CVE-2012-0002  Metasploit 취약성 테스트 Nessus DB 정보 내보내기 Metasploit Exploit Framework를 통해 대상 서비스 취약성 점검을 하기 위해\nNessus를 바탕으로 점검한 결과를 DB 형태로 내보내기를 진행 파일은 xml\n유형의 Nessus 확장자 구성으로 되어있으며 해당 파일일 작업 공간에 저장\n한다.  Metasploit workspace Metasploit 상에 취약점 점검 대상의 정보를 관리하기 위해 Nessus DB정보를\n받아와 작업할 공간을 만든다.  Metasploit DB 연결 상태 확인 및 가져오기 데이터베이스 상태를 확인한 후 만약 실패로 나온다면 PostgreSQL 서비스를\n키도록 한다. db_import 명령을 통해 다운 받은 Nessus DB 결과 정보를\n불러온다.  점검 대상 서비스 정보 확인 services 명령을 통해 서비스 정보를 확인한 결과 점검 대상인 msrdp/3389\n서비스가 …","frontmatter":{"categories":"windows 1-day","title":"CVE-2012-0002 1-day 취약점 분석","date":"December 07, 2020"},"fields":{"slug":"/cve_2012_0002_1-day/"}}},{"node":{"id":"812e049c-90ef-548b-ab1c-ca8d05b7f5d2","excerpt":"취약점 분석 바이너리 개요 보호 기법 main 함수 분석   함수를 바탕으로 1.alloc, 2. free, 3. exit 조건을 수행하는 것을 확인할 수 있다. alloc  메모리 동적할당 과정을 확인해 보면 전역 포인터 배열  에 할당하는 것을 확인할 수 있으며 인덱스 범위가 총19개까지 할당이 가능하다. 사용자의 입력값이  이하까지 size로 할당이 되어지며 해당 사이즈 만큼 데이터를 입력 할 수 있다. free  free되는 과정을 확인해 보면 사용자의 입력 값이 곧 인덱스 범위로 사용되어 원하는 힙을 해제할 수 있으며 기본적인 길이 검증이 존재한다. 하지만 해제한 초인터를 초기화하지 않기 때문에 Double Free Bug가 발생한다. memory leak Idea 어떻게 하면 메모리 주소값을 릭할 수 있을 까? 힙 청크의 데이터를 출력하는 기능이 존재하지 않아 다른 방법을 찾아야 한다. _IO_FILE_stdout  파일 디스크립터는 출력할 때 주로 사용하며 구조체로 수…","frontmatter":{"categories":"CTF","title":"d3ctf 2019 new_heap 취약점 분석","date":"September 18, 2020"},"fields":{"slug":"/d3ctf2019_new_heap_ctf_writeup/"}}},{"node":{"id":"8880760b-3ccd-50c9-b8e4-3779cab3598b","excerpt":"취약점 분석 바이너리 개요 보호기법 main 함수 분석 argc 스택 주소가 노출되는 것을 확인할 수 있으며, 총 4개의 메뉴를 선택할 수 있다. Add 메뉴는 동적 할당을 진행한다. Change는 해당 할당되어진 값을 변경한다. Delete는 해제 Check는 할당된 값을 확인할 수 있다. add 함수 add func <1:0x80, 2:0x110, 3:0x128, 4:0x150, 5:0x200> size를 선택해서 그 사이즈를 통해 동적 할당 add func 마지막 tIndex 증가 배열 설정한 구조체 대입  change 함수 할당되어진 구조체의 destination 부분을 변경할 수 있으며 tIndex 부분을 사용자가 직접 입력하여 trips 구조체의 주소 부분에 접근이 가능하다. choice 가 tIndex보다 클경우 함수를 종료하는 제어 문이 존재 하지만 해당 함수에서는 취약한 점이 존재한다.  데이터 타입은 signed 이기 때문에 음수를 처리할 수 있다 그렇다면 해당 …","frontmatter":{"categories":"CTF","title":"CSAW 2019 traveller 취약점 분석","date":"September 18, 2020"},"fields":{"slug":"/csaw2019_travelle_ctf_writeup/"}}},{"node":{"id":"527f840c-3346-5966-bbdf-58f7eb6e73ab","excerpt":"취약점 분석 바이너리 개요 보호기법  보호기법 NX PIE RELRO 바이너리 정보 바이너리 분석 메인 출력  메인 출력 부분 바이너리를 동작할 경우  문자열을 출력하면서 사용자의 입력 값을 받기 위해 대기 상태에 있는다. 사용자가 입력을 할 경우 만약 공백이면  문자열을 출력하면서 재 입력을 한며 카운터가 증가하지 않는다. 사용자가 입력을 할 경우 만약 입력 값이존재 한다면 어떤 로직을 바탕으로 검증을 하여 틀리게 되면  문자열을 출력하면서 카운터가 증가 한다. system call 추적  strace system call을 추적한 결과  함수가 ‘/home/ctf/flag’ 파일의 상태 여부와  함수를 바탕으로 읽기 전용으로 데이터를 읽어오는 것을 확인할 수 있다. 밑 분을 잘 보면  함수의 인자로  을 전달하여 seccom 보호 기법을 사용하는 것을 확인할 수 있으며  모드를 사용하여 블랙리스트 기반으로 접근제어를 하고 있다. SECCOMP_MODE_FILTER LIST da…","frontmatter":{"categories":"CTF","title":"Midnight sun 2019 gissa2 취약점 분석","date":"September 18, 2020"},"fields":{"slug":"/midnightsun_gissa2_ctf_writeup/"}}},{"node":{"id":"7aa9785d-9403-57d9-97d5-658045915602","excerpt":"취약점 분석 SROP 리눅스에서는 시그널이 들어오게 되면 커널 모드에서 처리한다. 커널 모드에서 유저모드로 들어오는 과정에서 유저의 스택에 레지스터 정보들을 저장해 놓는다.  은 이렇게 저장해놓은 정보들을 다시 돌려놓을 때 사용된다. 공격자가  시스템 콜을 호출할 수 있고 스택을 조작할 수 있다면 모든 레지스터와 > 세그먼트를 조작할 수 있다.  시스템 콜을 사용하여 익스폴로잇 하는 기법을 SigReturn Oriented Programming > (SROP)라고 한다. restore_sigcontext ,  매크로를 사용하여 레지스터및 세그먼트를 복원한다. sigcontext-32bit sigcontext-64bit 해당  구조체를 바탕으로 SROP 기법으 이용하여 공격을 진행할 수 있다. 문제 small_boi.c 문제 바이너리를 분석해 보면  , ,  등 익스를 하기에 필요한 명령들이 있는 것을 확인할 수 있으며 카니리 보호 기법이 걸려 있지 않아 버퍼 오버플로우를 발생시켜 …","frontmatter":{"categories":"CTF","title":"CSAW 2019 small_boi 취약점 분석","date":"September 18, 2020"},"fields":{"slug":"/csaw_small_boi_ctf_writeup/"}}},{"node":{"id":"9a41bca5-49de-507b-a5a7-cc4a31a34f6d","excerpt":"취약점 분석  기타 정보 statically linked, 64 bit Heartbeat packet 보호기법 No RELRO No Canary found NX enabled No PIE 바이너리 분석 main 함수 분석  flag 파일의 내용을 읽어와 flag 변수에 집어넣는 것을 확인할 수 있다.  flag 변수는 .bss 섹션에 존재하며 전역 변수로 확인된다. 사용자의 입력 값을 토대로 특정 조건을 수행하게 되는데  함수를 바탕으로 문자 단위로 짤라 해당 문자열이 포함되는 지를 확인하고 있다.  strtok 그후 해당 부분에서  까지 잘라 해당 문자열의 값을  전역 변수에 memcpy를 하는 것을 확인할 수 있다.  globals 전역 변수  전역 변수는 총 512바이트이며, 같은 .bss 영역이므로 앞에서 선언된 flag와는 0x200차이가 나는 것을 확인할 수있다.  0x200 바이트 차이  비교 strtok   한 내부의 특 정 정수 값을 바탕으로  함수의 인자로 쓰이는…","frontmatter":{"categories":"CTF","title":"DEFCON 2016 xkcd 취약점 분석","date":"September 18, 2020"},"fields":{"slug":"/defcon2016_xkcd_ctf_writeup/"}}},{"node":{"id":"737b51b9-e824-5c9a-b633-806160194839","excerpt":"취약점 분석 바이너리 개요  보호 기법 stripped statically linked 32 bit 보호기법 No RELRO Canary found NX enabled PIE disabled 바이너리 분석  로직 분석1  바이너리의 입력 값으로  를  입력한 결과 SSP가 켜지는 것을 확인할 수 있으며 해당 바이너리에는 카나리가 존재하는 것을 확인할 수 있다.  로직 분석2 하지만  바이너리의 입력 값으로 를  번 입력한 결과 SSP 켜지지 않는 것으로 보아 앞의 첫 바이트의 입력 값이 해당 다음 입력 값 즉, 문자열의 길이 값이 되는 것을 추측할 수 있다.  systemcall system 호출 범위를 분석하던 중  시그널을 보낸 후  함수를 바탕으로  출력을 하는 것을 확인할 수 있으며 다시 자식 프로세스를 생성하는 것을 확인할 수 있다. 이로 인해 해당 바이너리는  함수를 바탕으로 자식 프로세스를 생성하는 로직을 확인할 수 있다. main 함수 분석  main 함수 분석 ma…","frontmatter":{"categories":"CTF","title":"DEFCON 2016 feedme 취약점 분석","date":"September 18, 2020"},"fields":{"slug":"/defcon2016_feedme_ctf_writeup/"}}},{"node":{"id":"1de29c36-bdf1-5fda-b1dc-8d0f43ff9540","excerpt":"취약점 분석 바이너리 분석 바이너리 실행 결과 lib_system 주소가 노출되는 것을 확인할 수 있으며 4개의 옵션으로 해제 , 할당, 입력, 종료가 가능하다. 취약한 부분 메모리 주소 노출  lib_system 주소를 노출시키는 것을 확인할 수 있다. main 함수 부분  Bye 함수 부분  Exploit Idea 라이브러리 주소가 노출이되어 있기 때문에 해당 바이너리가 7가지 작업 만 수행 할 수 있으므로 작업을 낭비할 필요가 없다. 라이브러리 버전은 2.27 버전이며 tcache를 사용하고 있다. 바이너리 분석 결과 UAF를 직접적으로 가능하지 않기 때문에 tcache poisoning이 불가능 하다. 우리는 Double free buf를 바탕으로 tcache dup을 사용할 수 있다. 힙의 어느 위치에서나 해제가 가능하므로 tcache house of spirit을 사용할 수 있다. security check로 인해 작성하려는 위치에 fake chunk을 만들어야 한다. …","frontmatter":{"categories":"CTF","title":"CSAW 2019 popping_caps 취약점 분석","date":"September 18, 2020"},"fields":{"slug":"/csaw_popping_ctf_writeup/"}}},{"node":{"id":"4d7e0722-1f4d-5af4-aa3e-9d121de77521","excerpt":"취약점 분석 바이너리 개요 보호기법  security check CANARY NX PIE RELRO 바이너리 정보 바이너리 분석 바이너리 로직 흐름  main output 총 4개의 메뉴를 선택할 수 있는 선택창을 확인할 수 있으며 , , ,  메뉴가 존재한다. Buy 메뉴  Buy 메뉴 두 가지 선택으로  ,  을 선택할 수 있으며, 입력 값은  ,  대입 되는 것으로 확인된다. 두 번째  은 출력 문에  옵션 값들이 기본 세팅되는 것으로 확인된다. View 메뉴 {: width=“60%” height=“60%“} View 메뉴 Use 메뉴 앞에서 입력한  들을 출력해주는 형식이며, 인덱스를 바탕으로 출력하는 것으로 보아 구조체 배열 구조임을 추측할 수 있다. {: width=“60%” height=“60%“} Use 메뉴 0 번째 인덱스를 선택한 결과  문자열이 출력되지만 1 번째 인덱스 같은 경우 구조체 멤버들의 값을 설정할 수 있는 옵션을 추가적으로 할 수 있다. 0 번째 …","frontmatter":{"categories":"CTF","title":"SSTF 2020 t_express","date":"September 18, 2020"},"fields":{"slug":"/sstf2020_t_express_ctf_writeup/"}}},{"node":{"id":"8b2db8ca-f6eb-549e-abaf-e661c224717d","excerpt":"취약점 분석 Name\nmusicBlog Description\nYou can introduce favorite songs to friends with MusicBlog! File\nMusicBlog.tar.gz DockerFile 분석  PHP 7.4.0 버전을 사용하는 것을 확인할 수 있으며 해당 버전에 맞는 버그를 바탕으로 flag를 획득할 수 있겠다. 함수의  앞에 async 라는 예약어를 붙인후, 함수 내부에서 비동기 처리가 필요한 메서드에 await를 붙여준다. await 붙인 메서드는 비동기 처리 메서드가 꼭 promise 객체를 반환해야 await가 의도한 대로 동작한다. flag 문자열 찾기  flag 문자열을 검색하여  소스코드를 확인할 수 있다. 해당 코드를 보면 재선언, 재할당이 불가능하도록 설정되어 있다.  setUserAgent 메서드를 바탕으로 flag 값을 UserAgent로 설정하는 것을 확인할 수 있다. SamplePage   Sample Page 분석시…","frontmatter":{"categories":"CTF","title":"zer0pts ctf 2020 - musicBlof 취약점 분석","date":"August 24, 2020"},"fields":{"slug":"/zer0pts_music_ctf_writeup/"}}},{"node":{"id":"ef8ed1c7-9551-52fe-b73a-9e513ec3f2b6","excerpt":"취약점 분석 바이너리 실행 결과  입력 대기중 😑 바이너리 정보  main 함수 분석   번 루틴을 돌면서  함수를 바탕으로 입력을 받는다. 입력을 받을시 해당  버퍼를 사용하는데 해당 사이즈는 400바이트임을 계산할 수 있다.  루틴을 돌면서 400바이트 입력을 받은후 해당  를 인자로 하여  함수를 호출한후 해당 반환 값을 0이 아닐경우 FLAG 값을 출력하는 것을 확인할 수 있다. 출력 중간 사이에  함수가 보일텐데 해당 함수는  으로 해쉬화 하여 출력을 한다 즉, 해당 함수는 출력을 해쉬화 하는 과정이고 우리가 알아야 할 것은 어떤 걸 해쉬화를 하는지 입력 값을 바탕으로 어떤 조건을 통해 해쉬화 가되어지는지를 알아야 한다. sub_850 함수 분석 _start  _end  무려 시작과 끝의 옵셋 차이가 67493이 가 나는 함수 영역이다. …  처음 프롤로그 부분에서 스택 영역을  만큼이나 할당해준 후 무수히 많은 변수에 값을 대입하고 있다.  비슷한 구조로 한 블록에서 루…","frontmatter":{"categories":"CTF","title":"HitCon2017 Sakura 취약점 분석","date":"August 16, 2020"},"fields":{"slug":"/hitcon2017_sakura_ctf_writeup/2020-08-16-HITCON2017-sakura/"}}},{"node":{"id":"5a1f88d6-ed8e-53e3-88bb-4450a6a7a8df","excerpt":"LD_PRELOAD 환경 변수 다른 라이브러리보다 먼저 동적으로 링크하도록 라이브러리 경로를 지정한다. 해당 설정은 사전에 로드하는 라이브러리의 함수나 심볼을 나중에 링크되는 라이브러리 함수나 심볼을 오버라이드 한다. 공유 라이브러리 함수를 리다렉션하여 런타임 패치를 수행한다. LD_SHOW_AUXV 환경 변수 실행하는 동안 프로그램의 보조 벡터를 출력하도록 프로그램 로더에게 알린다.  는 프로그램의 스택 (커널의 ELF 로딩 루틴에 의한)에 위치한 정보로 프로그램에 관한 특정 정보와 함께 동적 링커로 전달된다. 해당 정보는 리버싱과 디버깅에 유용하다.  프로세스 이미지에 위치한  페이지의 메모리 주소는  를 확인해야 한다. 링커 스크립트 링커 스크립트는 링커가 해석해 섹션, 메모리, 심볼 등 프로그램의 레이아웃을 구성한다. 기본 링커 스크립터는  명령어로 확인한다.  링커 프로그램은 (재배치 가능한 객체 파일, 공유 라이브러리, 헤더 파일 등) 입력 파일을 받을 때 해석된다. 해…","frontmatter":{"categories":"AnalyzingBinaries","title":"리눅스 링커 환경 변수","date":"August 16, 2020"},"fields":{"slug":"/elf_device_file3/"}}},{"node":{"id":"140e0bac-bf87-5ae1-8ed8-bf36207900f7","excerpt":"Device File /proc//maps 각 메모리 매핑을 표시해 프로세스 이미지에 대한 레이아웃을 가진다. 실행 파일, 공유 라이브러리, 스택, 힙, VDSO 등이 포함된다. 프로세스 주소 공간의 배치를 신속히 분석할 때 매우 중요하다.  /proc/kcore proc 파일시스템에 있는 엔트리로 리눅스 커널의 동적 코어 파일처럼 행동한다. GDB에 커널 디버깅과 분석을 목적으로 사용할 수있는 ELF 코어 파일 형태인 로우 메모리 덤프이다. /boot/System.map 모든 리눅스 배포판에서 사용할 수 있고 커널 해커에게 아주 유용하다. 전체 커널의 모든 심볼이 담겨 있다. /proc/kallsyms kallsyms는 /proc 엔트리만 제외하고 커널이 관리하고 동적으로 업데이트하여  과 매우 유사하다. 새로운 LKM을 설치하면 심볼은 /proc/kallsyms에 바로 추가된다. /proc/kallsyms는 대부분의 심볼과  커널 설정에 명시된 것 전부가 포함된다.  /proc…","frontmatter":{"categories":"AnalyzingBinaries","title":"ELF 분석에 유용한 디바이스 파일 (Device File)","date":"August 16, 2020"},"fields":{"slug":"/elf_device_file1/"}}},{"node":{"id":"91454ee1-75f4-5953-a563-81ab9c730942","excerpt":"ELF 파일 형식 ET_NONE(ELF type none)  파일은 아직 정의되지 않았거나 알 수 없다. ET_REL(ELF Type relocatable) 재배열이 가능한 파일 형식 이 형식의 파일은 파일의 전체 또는 일부가 재배열 가능하다. 재배열 가능한 파일은 위치 독립 코드 (PIC, Position Independent Code) 라고 한다.  코드를 컴파일 해 얻을 수 있는  파일은 실행 파일을 생성하는 데 필요한 코드와 데이터를 포함한다. ET_EXEC(ELF executable) 실행 파일 형식이다. 이 형식의 파일은 실행 파일이며 프로그램이라고 부른다. 프로세스의 시작 지점인 Entry Point가 있다. ET_DYN(ELF type dynamic) 공유 오브젝트 파일 형식 동적 링킹이 가능한 오브젝트 파일로 공유 라이브러리하고도 함 실행 시간(runtime) 에 프로그램의 프로세스 이미지로 로드되고 링크된다. ET_CORE(ELF type core) 코어 파일 형…","frontmatter":{"categories":"AnalyzingBinaries","title":"ELF 파일 형식 (ELF file format)","date":"August 16, 2020"},"fields":{"slug":"/elf_device_file2/2020-08-16-ELF-file-format/"}}},{"node":{"id":"88ca51e5-5708-59c2-a863-767986781412","excerpt":"Objdump GNU Binutils 난독화 되지 않은 일반적인 바이너리를 디스어셈블링하여 작업할 수 있다. 일반적인 ELF 형식이라면 모두 읽을 수 있다. 예제 바이너리 ELF 파일의 모든 섹션, 데이터/코드 출력  ELF 파일의 프로그램 코드 출력  ELF 파일 모든 심볼 출력  Strace System Call Trace ptrace(2) 시스템 콜을 기반으로 하는 도구 프로그램이 실행되는 동안  활동에 대한 정보와 수집되는 시그널을 보여주기 위해 루프 안에서  요청을 사용한다. 프로세스를 디버깅하거나 실행 중일 때 어떤 syscall이 호출되는지에 대해 정보 수집으로 유용하다.  ltrace 라이브러리 트레이스 strace와 유사하다. 프로그램의 공유 라이브러리 링킹 정보를 파싱하고 사용되는 라이브러리 함수를 출력한다. 시스템 콜 외에 라이브러리 함수 호출도 확인하고자 할시  플래그를 사용한다. 실행 파일의 동적 세그먼트를 파싱하고 실제 공유 라이브러리와 정적 라이브러리의 …","frontmatter":{"categories":"AnalyzingBinaries","title":"ELF 분석 도구","date":"August 16, 2020"},"fields":{"slug":"/elf_device_file5/"}}},{"node":{"id":"2343cc79-a0f4-5501-afb9-7ffb82f62c18","excerpt":"ELF 프로그램 헤더 ELF 프로그램 헤더는 프로그램 로딩에 필요한 를 정의한다. 는 디스크에 저장된 실행 파일이 커널에 의해 로드되는 과정에서 어떤 메모리 구조로 매핑될 것인지를 정의한다. 프로그램 헤더 테이블은 ELF 헤더의 멤버인  (프로그램 헤더 테이블 오프셋)를 조회해 접근한다. 주로 사용하는 프로그램 헤더는 5가지로 실행 파일 및 공유 라이브러리의 세그먼트를 정의하고 세그먼트 형식(어떤 형식의 데이터 또는 코드가 있는지를 나타낸다.) 32비트 ELF 실행 파일의 프로그램 헤더 테이블을 조회해  구조체가 형성하는 프로그램 헤더를 분석해도록 하겠다. PT_LOAD 실행 파일에는  형식의 세그먼트가 하나 이상 있어야 한다. 해당 형식의 프로그램 헤더는 로드 가능한 세그먼트 형식으로 메모리에 로드 또는 매핑된다. 두 세그먼트는  값을 이용해 정렬된 후 메모리에 매핑된다. Phdr 구조체가 나타내는 세그먼트가 파일과 메모리에서 어떤 방식으로 동작하는지 이해하기 위해 리눅스의  페…","frontmatter":{"categories":"AnalyzingBinaries","title":"ELF 프로그램 헤더 (ELF Program Header)","date":"August 16, 2020"},"fields":{"slug":"/elf_device_file4/"}}},{"node":{"id":"093caa3f-71ec-5562-a741-87d4d08470d1","excerpt":"취약점 분석 Angry Bird 바이너리 동작 결과  바이너리 실행시 아무 결과가 안나오는 것을 확인할 수 있다. main 함수 분석   보호기법이 적용되어 있어 Stack Prlog를 거치면서  를  레지스터에 에서 생성된 값을 가져와 해당 값을 스택에 집어넣는 것을 확인할 수가 있으며  레지스터를 0으로 초기화 한후 0과 비교를 하여  함수로 점프하는 것을 볼 수 있다. 그래서, 해당 바이너리를 실행하였을 때 바로 끝나는 모습을 확인할 수 있다. Nop Sled 적용   Hex 값을 90(Nop)으로 패치하여 점프를 뛰어도 끝날 수 없도록 진행하였다.   디버거를 바탕으로  함수로 점프하는 것은 우회를 하여  문자열을 반환하는 것을 확인할 수있다. you should return 21 not 1 :( 출력된 결과를 확인해 보면 21을 반환해야 한다고 한다. 해당 함수를 분석해보도록 하겠다. Sub_4006F6 함수 분석  앞의 문자열을 출력한 함수 블록 내부이며 반환 되는 값 …","frontmatter":{"categories":"CTF","title":"CodeGate2017 angrybird 분석","date":"August 15, 2020"},"fields":{"slug":"/codegate2017_angrybird_ctf_writeup/"}}},{"node":{"id":"1978b95d-f40f-5966-9b18-e2d2a90b39e7","excerpt":"문제 해결 Step1: error check Docker환경에서 Ubuntu 서버를 운영하다가  이 작동을 안하는 경우가 생긴다. 해당 에러는  가 발생하며 local 쪽에 문제가 생긴 것으로 보인다. Step2  명령으로 해당 파일을 찾을 수 없다는 오류 메시지가 뜬다면은 아래에 환경 설정을 해주길 바란다. Step3 환경 설정을 완료하였으면  옵션으로 사용할 locales 를 지정하도록 한다.   을 선택하고  을 설정하도록 한다.  그 후에  이 잘되는 것을 확인할 수있다.😊😊  Step1: error check Step2 Step3","frontmatter":{"categories":"troubleshooting","title":"Docker Ubuntu 환경 Python pip locale 에러 해결 방안","date":"August 15, 2020"},"fields":{"slug":"/docker_python_tbs/"}}},{"node":{"id":"ad736f49-eb3e-5545-a7cb-d869773bd0e6","excerpt":"The Loader  를 로드하고 로더와 상호 작용 하는 방법에 대해 알아보자 예제로 사용할 바이너리는 다음 링크에서 다운로드: dnsdudrla97/angr-doc Loaded Objects CLE 로더 (cle.Loader)는 로드된 바이너리 객체의 전체 그룹을 나타내며 단일 메모리 공간에 로드되고 매핑된다. 각 바이너리 객체는 파일 형식(cle.Backend의 subclass)을 처리할 수 있는 loader backend에 의해 로드된다. 예를 들어, cle.ELF 는 ELF 바이너리 파일을 로드 하는 데 사용된다. 메모리에 로드된 바이너리 수 와 일치하지 않는 객체도 있을 것이며 예를 들어,  지원을 제공하는 데 사용되는 객체와 확인되지 않은 Symbols을 제공하는데 사용되는 외부 객체 CLE가  와 함께 로드한 전체 목록뿐만 아니라 다음과 같이 몇 가지 추가 표적 분류도 얻을 수있다. 해당 객체들과 직접 상호 작용하여 메타 데이터를 추출 할 수 있다. Symbols an…","frontmatter":{"categories":"AnalyzingBinaries","title":"angr 바이너리 분석 활용 방안 2","date":"August 14, 2020"},"fields":{"slug":"/angr-2_theori/"}}},{"node":{"id":"a1cbd834-e57e-573a-b4e3-0cc76df63a00","excerpt":"angr fauxware 문제 풀이 문제 바이너리 dnsdudrla97/angr-doc data 섹션  authenticate 함수   전역 변수가 가리키고 있는 문자열 과 유저 이름을  함수를 바탕으로 비교를 통해 같으면 1을 반환하고 아닐시 유저 이름에 해당 하는 파일 이름을  함수를 바탕으로 읽고 해당 값과 유저 패스워드와 비교하여 같으면 1을 반환 아니면 0을 반환한다. 우리가 피해야할 주소 값은  임을 알 수있다.  접근해야 하는 위치  기본적으로 앞에서  함수에서 반환된 값이 1 일 경우  함수를 호출하게 된다.  angr solve 1  angr sovle 2  data 섹션 authenticate 함수 접근해야 하는 위치 angr solve 1 angr sovle 2","frontmatter":{"categories":"AnalyzingBinaries","title":"angr 바이너리 분석 활용 방안 3","date":"August 14, 2020"},"fields":{"slug":"/angr-3_theori/"}}},{"node":{"id":"a9a71278-4019-5d76-9ba3-007bc03a8391","excerpt":"취약점 분석 안드로이드 앱의 시작점  MainActivty1  k() 의 반환값이 False 이면 앱 종료 K 함수 분석 빌드 네임이 아래 중 하나 조건에 맞으면 통과  MainActivity2 intent 요청 조건 분석  Button을 누르면 길이가 (10 ≥ && ≤ 26) 일 경우 Main2Activity 를 호출 MainActivity2  MainActivty에서 입력 받은 edittext 를 stringExtra 변수에 저장 obj에 Main2Activity에서 입력하는 값을 저장하고  함수를 stringExtra로 실행한 값과 일치하는지 비교한다. MainActivty에서 입력한 값이 id, Main2Acticity에서 입력한 값이 password인 것을 확인할 수 있다. MainActivity2 a 함수 분석 입력 받은 str(id) 를 갖고 xor 연산을 하면서  연산하는 함수 MainActivity3 분석   함수 반환 값과 Main3Activity 에서 입력하는…","frontmatter":{"categories":"Mobile","title":"Droid APK 취약점 연구","date":"August 14, 2020"},"fields":{"slug":"/droidCTF_droid_ctf_writeup/"}}},{"node":{"id":"63ac0101-7bca-525d-8b12-a5fa8beb3168","excerpt":"바이너리 정보 main 함수 분석 Undefined (U) → Create String (a) → WOW String     인코딩되어진 값을 확인할 수 있다. 사용자 입력을 27바이트를 받으며  ~  까지 함수 호출 과정이 끝나고  를 호출하는 것을 확인할 수 있다. ptrace Anti-Debugging    함수는 인자  을 받으며 호출되며 반환 되는 값이  값 즉,  과 비교되어 0 이 아니게 되면 정상 루틴이 아닌 다른 루틴으로 빠지는 것을 확인할 수 있었다.  의  옵션은 자기 자신에게 디버거를 붙이라는 의미로서 해당 코드에서는 의 결과가 -1인지 검사하고 참이라면 유효하지 않은 코드 영역으로 점프를 하게 된다. 즉 안티 디버깅을 하기 위해  하는 것이다.  안티 디버깅 검사를 마친 후에 다시  ~  까지 함수를 이용하여 입력값 검증을 시도한다.   함수의 반환 값을 인자로 삼아  함수가 호출되는 것을 확인할 수 있으며,   함수를 바탕으로 rax레지스터 즉, 검증 함수…","frontmatter":{"categories":"CTF","title":"CodeGate2018 RedVelvet write-up","date":"August 14, 2020"},"fields":{"slug":"/codegate2018_redvelbet_ctf_writeup/"}}},{"node":{"id":"eadfc36a-427f-5be4-b01b-4ce12d71c3c6","excerpt":"취약점 분석 바이너리 정보  바이너리 실행  입력 값을 받을 수 있도록 하며 임의의 문자열을 입력할 시  해당 문자열을 출력하는 것을 알 수 있다.    함수 호출 인자 , ,   함수 호출 인자 , ,  str1에 있는 문자열에서 str2 문자가 있을 경우 그 문자 까지의 개수를 리턴한다.  flag 값을 얻기 위해서는  함수를 거쳐서 반환 값이 1이어야 한다. 반환 값을 얻기 까지의 조건들이 너무 더럽다…  해당 조건을 디컴파일 한 결과 조건을 만족할 시 반환 되는 값은 1이다. 문제 제목 처럼 Z3를 통해 풀어보도록 하겠다. 해결 방안 SAT (Boolean SATisfiability problem) 주어진 Boolean 식을 충족시키는 해 (True로 표현되는 해)가 존재하는지 결정하는 문제 SAT는 명제논리식이기 때문에 각 변수에 True/False만 할당한다. 바이너리 정보 바이너리 실행","frontmatter":{"categories":"CTF","title":"Sharky CTF Z3 Robot","date":"August 14, 2020"},"fields":{"slug":"/sharkyCTF_z3z3_ctf_writeup/"}}},{"node":{"id":"0438ec05-4e99-5375-bbc9-e6cabe5115be","excerpt":"취약점 분석 바이너리 정보 해당 바이너리를 올바른 플래그와 함께 실행했을 때의 아웃풀 정보를 보여준다.  main 함수 분석   형의  배열은  함수로 초기화가 되어지며 argv오 입력한 길이 만큼 루틴을 돌면서  의 인덱스 로 사용되어 해당 값을 출력한다. 인수를 사용하여 바이너리를 실행하는지 확인하고, 계산 함수를 호출하고 마지막으로 결과를 출력한다. 출력 형식을 보면 16진수 형식의 결과를 알 수 있다. init_table 함수 분석  do~while 문을 바탕으로 을 초기화한 후 나머지 의 값은 0번째 값을 이용해 생성하는 것을 확인할 수있다. 에 올 수 있는 경우의 수는 256이기 때문에 생성될 수있는 의 수도 256가지 이다. 시간을 난수 시드로 사용하며 경우의 수가 다수이다. 해당 어셈블리어를 살펴보도록 한다.  하위 2 비트, 즉 0-ff의 경우 다음 ROR1 계산 만 취해 보겠다. 이것은 알고리즘이며 다시 되돌리수 없다. 그렇기 때문에 블라스팅의 사용은 제한된다. …","frontmatter":{"categories":"CTF","title":"TWCTF2016 ReverseBox 분석","date":"August 14, 2020"},"fields":{"slug":"/TWCTF_reversBOX_ctf_writeup/"}}},{"node":{"id":"2dc19ec9-63a6-5f68-aff2-ea70f9c0a6e9","excerpt":"프로젝트 선택 loader 이진 파일에서 가상 주소 공간에서 표현하는 것은 매우 복잡하다. 이를 처리하기 위하여 CLE 모듈이 있다. 로더라고 하는 CLE의 결과는 속성에서 사용할 수 있으며  프로그램과 함께 로드된 공유 라이버리를 보고 로드된 주소 공간에 대한 기본 쿼리를 숭행하는데 사용할 수 있다. p.factory (생성자들)  에는 많은 클래스가 있으며 대부분 프로젝트를 인스턴스화해야 한다. 모든 곳에서 프로젝트를 사용할 시 자주 사용하고 싶은 공통 객체에 대한 몇 가지 편리한 생성자를 제공한다.  block  주어진 주소에서 기본 코드 블록을 추출하는데 사용된다. state 객체는 프로그램의 “초기화 이미지” 만을 나타낸다.  로 실행을 수행할 때 시뮬레이션 된 프로그램 상태를 나타내는 특정 개체인  로 작업한다.  는 프로그램의 메모리, 레지스터, 파일 시스템 데이터를 포함하고 있다. 해당 값들은 파이썬의 정수가 아니다. 이다. 파이썬 정수는 CPU의 단어와 동일한 의미…","frontmatter":{"categories":"AnalyzingBinaries","title":"angr 바이너리 분석 활용 방안 1","date":"August 14, 2020"},"fields":{"slug":"/angr-1_theori/"}}},{"node":{"id":"e98f71b9-6f47-5a3d-935b-b2842c7c857d","excerpt":"GDB 명령어 및 함수 정리 시작 도움말 Breakpoints Stack Backtrace 소스내부 Data GDB 명령어 및 함수 정리 시작 도움말 Breakpoints Stack Backtrace 소스내부 Data","frontmatter":{"categories":"Tools","title":"GDB cheat sheet","date":"June 09, 2020"},"fields":{"slug":"/gdb_tools/"}}},{"node":{"id":"732469bd-2e89-5f14-b6a3-db94ed3a72b3","excerpt":"프록시 설정 방법 크롬 브라우저 위주 설정 (크롬 설정 → 시스템)  수동 프록시 설정 기본적으로 127.0.0.1:8080을 사용한다.  Burp Suite CA 인증서 설치 과정 (Chrome 인증 과정) Burp Suite를 바탕으로 SSL/TLS 암호화 기반의 HTTPS 웹 사이트를 탐색 할 경우 프록시는 인증 기관 (CA)으로 공유키 인증서로 서명된 각 호스트에 대해 SSL 인증서를 생성하게 된다.  CA 으로 발급된 인증서는 Burp Suite를 처음 구동하였을 때 로컬 환경에 저장이 된다. HTTPS 웹 사이트에서 Burp Suite Proxy를 사용하려면 브라우저에서 Burp Suite CA 인증서를  에 설치를 해야 된다. Burp Suite CA 인증서 발급 과정 Burp Suite 프록시 서버를 기점으로 로컬 환경 프록시가 세팅되어 있는 상태 Burp Suite CA 다운로드 크롬 웹 브라우저를 실행 시킨 후 주소창에  를 입력한다. Burp Suite 웹 사이…","frontmatter":{"categories":"troubleshooting","title":"BurpSuite 인증서 설치 방법","date":"June 06, 2020"},"fields":{"slug":"/BurpSuite_tbs/"}}},{"node":{"id":"11e31e7e-8f1d-5d7e-9978-d3a4987d44fe","excerpt":"Metasploit 아키텍처 Metasploit은 Ruby로 작성되었으며 수년 동안 개발되었다. 언뜻보기에 프로젝트의 규모는 어려울 수 있지만 아키텍처를 깊게는 파고들 필요가 없다.  Metasploit 파일 시스템 및 라이브러리에 익숙해지면 좀더 능숙하게 작성할 수 있겠다. Kali Linux에서 Metasploit은 metasploit-framework 패키지로 제공되며  디렉토리에 설치된다. Metasploit FileSystem MSF 파일 시스템은 직관적 인 방식으로 배치된다. Data Data 디렉터리는 특정 공격, 단어 목록, 이미지 및 더 필요한 바이너리에 MSF에서 사용하는 편집 가능한 파일이 포함되어 있다. Documentation Documentation 디렉터리에는 프레임 워크에 사용 가능한 문서가 포함된다. LIB LIB 디렉터리는 프레임 워크 코드 기반의 라이브리들이 포함 된다. Module Module 은 공격, 보조 및 사후 모듈, 페이로드, 인코더, …","frontmatter":{"categories":"Tools","title":"Metasploit 아키텍처 및 파일 시스템 구조 이해","date":"June 05, 2020"},"fields":{"slug":"/Metasploit2_theori/"}}},{"node":{"id":"a28b5e01-0cbc-5e7d-8a57-bac2d88809d6","excerpt":"하드 드라이브 공간 10 GB 이상의 사용 가능한 저장 공간 대용량 파일 시스템을 지원하는 NTFS, EXT3 또는 기타 파일 시스템 형식을 선택 해야 한다. 필요한 권장 공간 30 GB 정도 사용 가능한 메모리 호스트 OS에 RAM과 각 가상 머신에 할당하는 RAM의 충분한 양이 필요한다. Linux 호스트 최소 메모리 요구 사항 1GB의 시스템 메모리 (2GB 정도면 적당) Kali Linux Guest 최소 메모리 요구 사항 최소 1GB의 RAM (2GB 권장) 프로세서 64 bit 쿠드 코어 CPU 이상을 권장한다. AWS (Amazon Web Server) 상에서 칼리 리눅스, 메타스폴로잇을 구동을 하여 외부 서비스를 점검을 하게 된다. 대외적으로 클라우드 서비스 환경에서도 올려 사용하고 있다. METASPLOITABLE (피해자 환경) 악용 프레임 위크를 사용하는 방법을 배울 때 발생하는 문제 중 하나는 검색하고 공격 할 대상을 찾고 구성하는 것 해당 이미지는 의도적으로…","frontmatter":{"categories":"Tools","title":"Metasploit 환경 구성","date":"June 05, 2020"},"fields":{"slug":"/Metasploit1_theori/"}}},{"node":{"id":"c84a2764-f589-5841-87d8-3db17c294c1d","excerpt":"윈도우 실행 파일 구조 PE 파일 (Portable Excutable) 다양한 정보를 포함한 커다란 구조체들로 이루어져 있다. 수만은 테이블과 멤버들을 포함하고 있다. PE 파일의 종류 종류 설명 EXE 실행파일 SCR 실행파일 (화면 보호기) DLL 라이브러리 OCX 라이브러리 (ActivieX) SYS 시스템 드라이버 OBJ 오브젝트 파일 SCR 파일이 실행 파일임을 인지 하지 못한채 악성 코드로 동작하게 되어 피해가 발생한 경우가 다수 첫 바이트 부터 시작된다. PE 파일은 파일에 존재할 때의 구조와 메모리에 로드된 후의 모습이 달라진다. 파일에서는 첫 바이트부터의 거리를 offset을 사용한다. 메모리에서는 VA(Virtual Address), RVA(Relative Virtual Address, 상대적 가상 주소) 고정 주소 대신 상대 주소를 사용하는 이유는 해당 PE 파일이 메모리에 로드 될 때 한 주소에 고정적으로 로딩되는 것이 아니기 떄문이다. 메모리에 로드된 후에 …","frontmatter":{"categories":"Windows Theory","title":"Windows PE","date":"June 02, 2020"},"fields":{"slug":"/windowPE_theori/"}}},{"node":{"id":"20fc7bd8-cb14-5f2a-95a9-bd2eee50cee4","excerpt":"취약점 사용자에게 허용된 권한 이상의 동작이나 정보 열람을 가능하게 하는 소프트웨어의 설계상의 허점이나 결함 소프트웨어, 하드웨어, 절차 및 관리 등 넓은 의미를 예기하지만 중점은 기술적 소프트웨어 결함 을 통한 취약점 발생 여부이다. Exploit 취약점이 발견되면 해당 취약점을 공격하여 원하는 코드를 실행하거나 툭정 목적을 달성하는 공격 코드 또한 공개 된다. 이런 취약점 공격 코드를 Exploit이라 부르며 이러한 공격 코드를 이용한 공격 행위 일체를 포함하기도 한다. Exploit 공개 범위 유로 Exploit 무료 Exploit 악의적인 Exploit (공개 X) Offensive Security’s Exploit Database Archive 취약점 발견 및 패치 발견되는 취약점인 경우 대부분이 연구 목적으로 공개가 되어 지면서 동시에 해당 취약한 제품을 다루는 기업들은 그에 맞춰 패치가 이뤄진다. 하지만 취약점을 악의적으로 사용할 경우 공개를 하지 않고 서 군사적 일부…","frontmatter":{"categories":"Talk","title":"Exploit, 취약점 ?","date":"June 01, 2020"},"fields":{"slug":"/vuln_exploit_talk/"}}},{"node":{"id":"c48e199e-c684-5a7d-bbda-025aa1599bd3","excerpt":"Lua 언어 정리 주석 처리 변수 처리 모든 수는 double 형으로 받는다. 64bit double 형에는  총 52bit의 정수값을 저장할 수 있다. 코드 블록 표기법 블록은 do, end로 표기된다. 변수 및 흐름제어 함수 테이블 테이블은 루아의 유일한 합성 자료 구조이다. 테이블은 연관 배열이다. php 배열, 자바스크립트 객체와 비슷하다. 테이블은 리스트로도 사용될 수 있는 해시 참조 사전이다. 메타데이블과 메타메소드 테이블 하나는 메타테이블 하나를 가질 수 있다. 그 메타테이블은 ‘연산자 오버로딩’을 제공한다. 클래스 와 유사한 테이블과 상속 클래스는 (루아)에 내장되어 있지 않다. 클래스는 테이블과 메타테이블을 사용하여 만들어진다. Dog는 클래스처럼 동작한다. (Dog는 테이블 형식이다.) function 테이블이름:함수(…)는 function 테이블이름.함수(self,…) 동일하다. ‘:’은 단지 함수의 첫 인자에 self를 추가한다. newObj(새 객체)는 클래…","frontmatter":{"categories":"Language","title":"Lua 언어 정리","date":"May 29, 2020"},"fields":{"slug":"/Lua/"}}}]},"site":{"siteMetadata":{"language":"ko","author":{"name":"Zer0Luck","bio":{"role":"Hacker","description":["Play!","We!","Exploit!"],"thumbnail":"z_l.png"},"social":{"github":"https://github.com/dnsdudrla97","linkedIn":"","email":""}}}}},"pageContext":{}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437","3350743975"]}